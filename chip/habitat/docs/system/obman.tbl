.de Ob
.IP "\\fHObject: "
.ft B
.nr PD 0
.nr PS +1
..
.de De
.nr PS -1
.IP "    \\fHDescription: "
.ft R
..
.de Fu
.IP "    \\fHFunction: "
.ft R
..
.de No
.IP "    \\fHNotes: "
.ft R
..
.de Sy
.IP "    \\fHStyles: "
.ft C
.nf
..
.de Pr
.IP "    \\fHProperties: "
.ft C
.nf
..
.de Cl
.IP "    \\fHClass properties: "
.ft C
.nf
..
.de Co
.fi
.IP "    \\fHCommand Behavior: "
..
.de Do
.IP "        \\fHDo: "
.ft C
..
.de Go
.IP "        \\fHGo: "
.ft C
..
.de St
.IP "        \\fHStop: "
.ft C
..
.de Ge
.IP "        \\fHGet: "
.ft C
..
.de Pu
.IP "        \\fHPut: "
.ft C
..
.de Ta
.IP "        \\fHTalk: "
.ft C
..
.de Re
.IP "        \\fHReversed Do: "
.ft C
..
.de In
.IP "    \\fHInitialization: "
.ft C
..
.de Dy
.IP "    \\fHDestruction: "
.ft C
..
.de As
.IP "    \\fHAsynchronous actions: "
.ft C
.nf
..
.de Gr
.IP "    \\fHGraphics: "
.ft R
..
.de Hp
.IP "    \\fHHost properties: "
.ft C
.nf
..
.de Hb
.IP "    \\fHHost behavior: "
.ft C
.nf
..
.de En
.nr PD 3.6p
.sp
\l'68'
.sp
.bp
..
.ds Da April 1, 1986
.lg 1
.ds T \v'-3p'\s-5TM\s+5\v'3p'
.ds M \v'-9p'\s-8TM\s+8\v'9p'
.TL
\s+9MicroCosm\*M Object Manual\s-9
.AU
the MicroCosm Object Set described in excruciating detail
.AI
Chip Morningstar
Lucasfilm Ltd. Games Division
\\*(Da
.ds LH OBJECT MANUAL
.ds CH \\*(Da
.ds RH MicroCosm Document # 20
.ds LF Lucasfilm Ltd. Proprietary Information
.ds CF - % -
.ds RF CONFIDENTIAL
.AM
.SH
\s+3Introduction\s-3
.PP
This document describes the basic set of objects from which the
\fBMicroCosm\fP fantasy world is constructed.  It both augments and
\fIsupersedes\fP the earlier document \fIMicroCosm Minimal Object Set\fR.
This document describes what the various objects are and specifies them in
sufficient detail that they may actually be programmed.
.SH
\s+3The Object Environment\s-3
.PP
Each object is a member of some \fIclass\fP of objects, i.e., it is one of a
group of objects that are all of the same basic type.  An object's class
determines what its behavior is going to be and how it is going to look on the
screen.  Each class is represented in the \fBMicroCosm\fP system by a \fIclass
descriptor\fR.  The class descriptor is a collection of data and executable
code that defines objects of a given type.  Creating the object set really
means creating the class descriptors for all of the classes of objects
described in this document.
.PP
Any actual object is an \fIinstance\fP of a particular class.  Each object is
represented by an \fIinstance descriptor\fR.  Instance descriptors are created
and destroyed as objects come and go from the system.  Each instance
descriptor is simply a small area of memory set aside to contain the data that
describes the state of a particular object (as distinguished from other
objects of the same class).  The memory address of an object's instance
descriptor can serve, internally, as a unique identifier for the object
itself.
.PP
This abstract model of classes and instances is used both in the home and in
the host systems.  The format and content of the class and instance
descriptors will differ across systems, of course, depending on the role that
each half of the system plays in the object's existence.
.ds LH CLASS DESCRIPTORS
.SH
\s+3Class Descriptors\s-3
.PP
The information describing a class consists two things: \fIimagery\fP and
\fIbehavior\fP.  The class descriptor itself is just a data structure that
points at these things.  The actual imagery and behavior are stored
separately.  This way, classes can share imagery and behavior when they
overlap between classes (which, in the case of behavior, is common).
.PP
\fIImagery\fP consists of the animation cels or graphics driver tables
required for the graphics software to display the object.  Most objects
consist of a single static image.  A few have a small number of images, one of
which is displayed at any given time depending on the state of the object.
Some have a more complex set of images that are used to vary the appearance of
the object according to some parameter (so that all objects of the class will
not appear identical on the screen) or to animate the behavior of the object
(avatars are the primary example of this).  In any case, the imagery is a set
of static data that is used by the graphics routines.  Interpretation of this
data may depend on object state information that the graphics routines obtain
from the object's instance descriptor.
.PP
\fIBehavior\fP consists of a set of executable routines that are called by the
object database software.  The class descriptor contains a vector of entry
points.  Each element in this vector has a particular, pre-assigned meaning.
Each entry point corresponds to a particular function that the object can be
called upon to perform.  Some of these functions are standard and all classes
can perform them.  These include responding to any of the verbs used in the
player interface.  Other functions are specific to the class itself and will
be called as the result of messages from the opposite end of the
communications line (the host if this is the home system, and vice-versa).
.PP
The class descriptor in the home system is laid out as follows:
.TS
c c l
np-2 | cb | l .
\fIByte\fP	\fIEntry\fP	\fIDescription\fP
	_
0\(mi1	length	Length of the class descriptor
	_
2	image#	Number of images this class uses
	_
3	sound#	Number of sounds this class uses
	_
4	action#	Number of behaviors this class uses
	_
5	imageOff	Offset in this class descriptor to first image ptr
	_
6	soundOff	Offset in this class descriptor to first sound ptr
	_
7	actionOff	Offset in this class descriptor to first behavior ptr
	_
8	objSize	Length to create objects of this class
	_
9	initSize	Number of initialization bytes expected from the host
	_
10	capacity	Number of objects containers of this class can hold
	_
11	maxOccp	Number of occupants seats of this class can hold
	_
12\(miN-1	\fIimages	Image pointers for this class
	_
N\(miM-1	\fIsounds	Sound pointers for this class
	_
M	do	Action for the standard verb \fBdo\fR
	_
M+1	rdo	Action for the standard verb \fBreversed do\fR
	_
M+2	go	Action for the standard verb \fBgo\fR
	_
M+3	stop	Action for the standard verb \fBstop\fR
	_
M+4	get	Action for the standard verb \fBget\fR
	_
M+5	put	Action for the standard verb \fBput\fR
	_
M+6	talk	Action for the standard verb \fBtalk\fR
	_
M+7	destroy	Destroy an instance of this class
	_
M+8+	...	Asynchronous actions directed by the host
.TE
There may be additional entry points beyond this.  These correspond to the
class-specific behavior functions discussed above.
.ds LH INSTANCE DESCRIPTORS
.bp
.SH
\s+3Instance Descriptors\s-3
.PP
An instance descriptor is a data structure that describes the state of one
particular object.  Each instance descriptor is a simple vector of bytes.
This vector has two parts: the first ten bytes form the \fIgeneric part\fP and
the remaining bytes (if any) form the \fIclass-specific part\fP.  The generic
part contains information that is common to all objects, regardless of class.
The layout of the generic part of the instance descriptor is the same for all
objects, so that external software can manipulate the information it contains
without having to know what sort of object it is part of.  The class-specific
part contains information that depends on what sort of object the object is.
The interpretation of this information is solely at the discretion of the
behavior code associated with the particular class of object.
.PP
The instance descriptor in the home system is laid out as follows:
.TS
c c l
np-2 | cb | l .
\fIByte\fP	\fIEntry\fP	\fIDescription\fR
	_
0-1	length	Length of this instance descriptor
	_
2	noid	Identifier by which this object is known to host
	_
3	class	Class of this object
	_
4	grstyle	Which style of this class of object to display as
	_
5	x	X-coordinate position within containing object
	_
6	y	Y-coordinate position within containing object
	_
7	orient	Orientation to display object in
	_
8	grstate	Graphic state to display object in
	_
9	aniStart	Starting graphic state of animation sequence
	_
10	aniEnd	Ending graphic state of animation sequence
	_
11	container	Object containing this object
	_
12-N	contents	Contents of container, if any
	_
N+	...	Class-specific information
.TE
.PP
The structure of an instance descriptor in the host system depends on the
structure of the host database, which has not yet been defined.  However, the
generic information it contains will be the same except for graphic state data
(which is obviously not needed in the host).  In the object descriptions that
follow, we will speak as if the host instance descriptor was essentially the
same as the home instance descriptor, though in actual practice the access
methods used will differ.  Class-specific information in the host will depend
on the needs of the class' behavior code, as it does in the home system.
.ds LH OBJECT DESCRIPTION
.bp
.SH
\s+3The Object Descriptions\s-3
.PP
What follows is a series of object descriptions, one for each class of objects
in the basic object set.  Each description has the following form:
.IP "\fHObject: "
.nr PD 0
.nr PS +1
\fBname of object\fP
.De
A brief description of the object.
.Fu
The object's purpose in the MicroCosm world.
.No
Anything else that needs to be said about the object.
.Sy
\fRStylistic variations possible for this object.
.Pr
.fi
\fRThe object's properties, i.e., the contents of the class-specific part of
the home system instance descriptor.
.Cl
\fRProperties associated with the object's class.
.Hp
\fRAdditional object properties that are kept only in the host.
.Co
.Do
\fRThe action to take for the verb \fBdo\fP.
.Go
\fRThe action to take for the verb \fBgo\fP.
.St
\fRThe action to take for the verb \fBstop\fP.
.Ge
\fRThe action to take for the verb \fBget\fP.
.Pu
\fRThe action to take for the verb \fBput\fP.
.Ta
\fRThe action to take for the verb \fBtalk\fP.
.Re
\fRThe action to take for the verb \fBreversed do\fP.
.In
\fRThe action to take on object initialization.
.Dy
\fRThe action to take on object destruction.
.As
.fi
\fROther behavior that the object should be capable of as a result of
asynchronous messages from the host or calls from other objects or other parts
of the home system.
.Gr
The graphics required of the object.
.Hb
\fRBehavior functions resident in the host.
.nr PD 3.6p
.sp
\l'68'
.sp
.PP
Throughout the descriptions we use a \fBC\fP-like pseudo-code to describe
specific behaviors.  A few words about the notation are appropriate:
.PP
Object properties (the contents of an instance descriptor), both generic and
class-specific, are referred to by name using identifiers in \fCthis
typewriter-like typeface\fR.  Such references look like \fBC\fR struct
references of the form \fCobject.property\fR.  The identifier \fCself\fP
refers to the object whose behavior we are executing, so that, for example
\fCself.class\fR is the object's class number and \fCself.x\fR is the object's
X-coordinate location.  Similarly, the identifier \fCavatar\fR refers to the
instance descriptor of the player's avatar, \fCregion\fP refers to the
instance descriptor of the current region, and \fCselfClass\fP refers to the
class descriptor of the object \fCself\fP.  Identifiers in \fCCAPITALS LIKE
THIS\fR are symbolic constants which should be described in the text.
.PP
One peculiar expression you will see frequently in the home system object
behaviors is:
.nf

        \fC@ object!ACTION (arg1, arg2, ...) \(-> (result1, result2, ...)\fR

.fi
This is an instruction to send a message to the host.  \fCobject\fP denotes
the object to whom the message is addressed.  \fCACTION\fP denotes the
particular action from that object that is desired.  The \fCarg\fPs are any
arguments to be sent with the message.  The \fCresult\fPs are the identifiers
to bind to the successive bytes of the response.  A similar form:
.nf

        \fCACTION (arg1, arg2, ...) \(-> (result1, result2, ...)\fR

.fi
is used in the host system behavior definitions as a header for a single
behavior definition, much like a \fBC\fR function header.
.PP
Some other odd expressions are found in the host system object behaviors:
.nf

        \fCobject \(-> ACTION* (arg1, arg2, ...)\fR

.fi
This is an instruction to send a message back to the home system.
\fCobject\fR denotes the object to whom the message is addressed.
\fCACTION*\fR denotes the particular action the object should take.  The
\fCarg\fRs are any arguments to be sent with the message.  Note that there is
only a single host system copy of any particular object, since there is only
one host.  However, there are as many home system copies of an object as there
are avatar's in the current region.  This expression indicates that the
message indicated should be sent to the computer of the player whose behavior
request we are currently processing.  The expression:
.nf

        \fC# object \(-> ACTION* (arg1, arg2, ...)\fR

.fi
is similar, except that the message is to be sent to every player in the
region \fIexcept\fP the one whose behavior request we are currently
processing.
.PP
Also, in messages to the host, the home system refers to objects using a
single byte object identifier.  The expression
.nf

        \fC\(ua objectId\fR

.fi
denotes the object instance descriptor for the object to which \fCobjectId\fP
refers.
.PP
Flow-of-control constructs, function and procedure calls, expressions, and
other such things resemble those found in \fBC\fR.
.ds LH HOME SYSTEM FUNCTIONS
.bp
.SH
\s+3Home System Standard Actions and Functions\s-3
.PP
In the object descriptions that follow, these functions are often used for
or within object behaviors.  These standard functions are provided because the
objects share a common underlying world model and there is much redundancy in
the user interface.  They provide both consistency and a significant reduction
in the amount of code which must be created and stored.
.LP
.nf
\fCadjacent(object)
{
    \fI/* Test for adjacency. To be adjacent, object must be within a foot of
       the avatar but not right where the avatar is. */\fC
    return(object.container==region && (abs(object.x - avatar.x)==1 ||
                                        abs(object.y - avatar.y)==1))
}

adjacentOpenClose()
{
    \fI/* If adjacent, open/close door or gate.  Otherwise, depends. */\fC
    if (adjacent(self)) {
        openClose()
    } else {
        depends()
    }
}

adjacentOpenCloseContainer()
{
    \fI/* If adjacent, open/close container.  Otherwise, depends. */\fC
    if (adjacent(self)) {
        openCloseContainer()
    } else {
        depends()
    }
}

amongContents(object, container)
{
    for (i=0; i<(lookupClass(container.class).capacity; ++i) {
        if (container.contents[i] == object) {
            return(TRUE)
        }
    }
    return(FALSE)
}

answer(phone)
{
    \fI/* Answer the phone if it is ringing. */\fC
    @ phone!ANSWER () \(-> (success)
    soundEffect(SOUND_CLICK_CLUNK)
    avatar.action = UNHOOK
    if (success) {
        phone.state = PHONE_TALKING
        soundEffect(SOUND_SILENCE)
    } else {
        soundEffect(SOUND_LINE_THUMP)
        if (phone.class == PHONE_BOOTH_CLASS) {
            phone.state = PHONE_OFF_HOOK
        } else {
            phone.state = PHONE_ACTIVE
        }
        soundEffect(SOUND_DIAL_TONE)
    }
}

answerOrUnhook(okToProceed, unhookedState)
{
    \fI/* Answer the phone if it's ringing, otherwise just pick up the
       receiver. */\fC
    if (okToProceed) {
        if (self.state == PHONE_RINGING) {
            answer(self)
        } else if (self.state == PHONE_READY) {
            @ self!UNHOOK () \(-> ()
            self.state = unhookedState
            avatar.action = UNHOOK
            soundEffect(SOUND_CLICK_CLUNK)
            soundEffect(SOUND_DIAL_TONE)
        }
    }
}

balloonMessage(source, format, arg1, arg2, arg3)
{
    \fI/* Output text using the Balloon-O-Matic.  \fCsource\fP denotes
       the object that is "speaking", i.e., the object to which the quip
       should point.  \fCformat\fP and the \fCarg\fPs specify the text
       to print using the conventions of the Unix \fCprintf\fP function. */\fC
    \fB/* In Randy's Balloon-O-Matic code. */\fC
}

broadcast()
{
    \fI/* Broadcast typed text to everyone in region */\fC
    balloonMessage(avatar, \fItext\fP)
    @ avatar!SPEAK (NULL, \fItext\fC) \(-> ()
}

cease()
{
    \fI/* Stop any on-going action. */\fC
    \fB/* *** nop? *** */\fC
}

changeContainers(object, newContainer, newX, newY)
{
    \fI/* Move \fCobject\fI from wherever it is now to the indicated
       (x, y) location in the indicated new container. */\fC
    object.container.contents[object.y] = NULL
    object.container = newContainer
    object.x = newX
    object.y = newY
    newContainer.contents[newY] = object
}

climbInOrOut()
{
    \fI/* If in a vehicle, get out.  If adjacent, get in.  If elsewhere, walk
       to it.  Only works when vehicle is not moving. */\fC
    if (!self.moving) {
        if (elsewhere(self)) {
            goTo()
        } else {
            sitOrGetUp()
        }
    }
}

concatenateStrings(s1, s2)
{
    \fB/* *** Return the concatenation of the two strings \fCs1\fP and
       \fCs2\fP. *** */\fC
}

createObject(class, container, x, y)
{
    \fI/* Create and object of the specified class located at the given
       (x,y) location within the given container.  Return a pointer to the new
       instance descriptor. */\fC
    \fB/* In Ron's database code. */\fC
}

createPaperObject(\fItext\fC)
{
    \fI/* Create a paper object with text on it. */\fC
    object = createObject(PAPER_CLASS, region, avatar.x, avatar.y)
    object.text = \fItext\fC
    return(object)
}

damageAvatar(who, damage)
{
    \fB/* When an avatar is injured, subtract \fCdamage\fP from his health
       and apply the appropriate effects accordingly. *** figure out what this
       means and how to do it. *** */\fC
}

depends()
{
    \fI/* Punt to reversed do. */\fC
    target = self
    if (!emptyHanded()) {
        self = avatar.inHand
    } else {
        self = avatar
    }
    (self.reversedDo)()
}

destroyObject(object)
{
    \fI/* Destroy the given object.  I.e., delete it and garbage collect
       all its resources. */\fC
    \fB/* In Ron's database code. */\fC
}

destroyObjectDramatically(object)
{
    \fI/* When we want to blow something up, rather than simply deleting
       it. */\fC
    (object.destroy)()
    destroyObject(object)
}

dialOrTalk(okToProceed)
{
    \fI/* If ok to proceed, interpret text as a phone call: first text message
       is phone number, further messages are conversation with the person at
       the other end.  When you enter the number, it is dialed.  If there is
       an answer, you can talk.  If not, the phone is deactivated when you
       hang up.  If not active, broadcast. */\fC
    if (okToProceed && self.state == PHONE_ACTIVE) {
        @ self!DIAL (\fItext\fC) \(-> (success)
        soundEffect(SOUND_DIAL, \fItext\fC)
        if (success) {
            self.state = PHONE_LINE_RING
            soundEffect(SOUND_LINE_RING)
        } else {
            self.state = PHONE_LINE_BUSY
            soundEffect(SOUND_BUSY_SIGNAL)
        }
    } else if (okToProceed && self.state == PHONE_TALKING) {
        balloonMessage(avatar, \fItext\fP)
        @ self!TALK (\fItext\fC) \(-> ()
    } else {
        broadcast()
    }
}

doMagic()
{
    \fI/* If in hand, do magical function.  Otherwise, depends. */\fC
    if (holding(self)) {
        @ self!MAGIC () \(-> ()   \fI/* Works asynchronously. */\fC
    } else {
        depends()
    }
}

doMagicIfMagic()
{
    \fI/* If magic and in hand, do magical function.  Otherwise, depends. */\fC
    if (holding(self)) {
        if (self.magic) {
            @ self!MAGIC () \(-> ()   \fI/* Works asynchronously. */\fC
        }
    } else {
        depends()
    }
}

dropAt()
{
    \fI/* Drop the object in hand on the ground at the location of self. */\fC
    putInto(region, self.x, self.y, DROP)
}

dropHere()
{
    \fI/* Drop the object at the avatar's location. */\fC
    putInto(region, avatar.x, avatar.y, DROP);
}

dropInto()
{
    \fI/* Drop the object in hand in the container self, if you can. */\fC
    putInto(self, NULL, NULL, PUT)
}

dropIntoIfOpen()
{
    \fI/* Drop the object in hand in the container self, if it's open. */\fC
    if (self.open) {
        putInto(self, NULL, NULL, PUT)
    } else {
        putInto(region, self.x, self.y, DROP)
    }
}

dropOnto()
{
    \fI/* Drop the object in hand on self, if you can. */\fC
    putInto(self, NULL, NULL, PUT)
}

elsewhere(object)
{
    \fI/* Test if object is elsewhere.  To be elsewhere, object must be
       neither where the avatar is nor adjacent to him nor on his person. */\fC
    return(!here(object) && !adjacent(object) && object.container!=avatar)
}

emptyHanded(who)
{
    \fI/* Return \fCTRUE\fP iff the avatar is not holding anything. */\fC
    return(who.inHand == NULL)
}

enterOrExit()
{
    \fI/* If not adjacent to self, go to it.  If adjacent, enter it.  If
       inside, exit it. */\fC
    if (here(self)) {
        goExit()
    } else {
        goOnto()
    }
}

explosionAt(x, y, size)
{
    \fB/* *** Animate an explosion of the given size at the given
       location. *** */\fC
}

get(object)
{
    \fI/* Tell host to grab the object, then update location and containership
       if the operation was successful. */\fC
    if (emptyHanded(avatar)) {
        @ object!GET () \(-> (success)
        if (success) {
            changeContainers(object, avatar, NULL, HAND)
            avatar.action = PICKUP  \fB/* *** What if picking from container? *** */\fC
            subjectObject = object
            return(TRUE)
        }
    }
    return(FALSE)
}

goAcross()
{
    \fI/* Walk to position opposite from present position w.r.t. the object's
       location, if you can. */\fC
    if (here(self)) {
        return(goPreferred())
    } else if (adjacent(self)) {
        return(goXY(oppositeX(self.x), oppositeY(self.y)))
    } else {
        return(goTo())
    }
}

goEnter()
{
    \fI/* Walk into object, via preferred adjacent position. */\fC
    return(goTo() && goPreferred() && goOnto())
}

goExit()
{
    \fI/* Walk out of object to preferred adjacent position. */\fC
    return(goPreferred())
}

goOnto()
{
    \fI/* Walk to the object's location, if you can. */\fC
    return(goXY(self.x, self.y))
}

goOntoAndDropAt()
{
    \fI/* Put hand-held item at object's location. */\fC
    if (goOnto()) {
        dropAt()
    }
}

goPreferred()
{
    \fI/* Walk to preferred adjacent position. */\fC
    goXY(self.preferredX, self.preferredY)
}

goTo()
{
    \fI/* Walk to nearest position adjacent to the object's location, if you
       can. */\fC
    return(goXY(nearestAdjacentX(self.x), nearestAdjacentY(self.y)))
}

goToAndDropAt()
{
    \fI/* Put hand-held item by object's location. */\fC
    if (holding(self)) {
        dropHere()
    } else if (goTo()) {
        dropAt()
    }
}

goToAndDropInto()
{
    \fI/* Put hand-held item into object. */\fC
    if (holding(self)) {
        dropHere()
    } else if (goTo()) {
        dropInto()
    }
}

goToAndDropIntoIfOpen()
{
    \fI/* Put hand-held item into object if it's open. */\fC
    if (holding(self)) {
        dropHere()
    } else if (goTo()) {
        dropIntoIfOpen()
    }
}

goToAndDropOnto()
{
    \fI/* Put hand-held item onto object. */\fC
    if (holding(self)) {
        dropHere()
    } else if (goTo()) {
        dropOnto()
    }
}

goToAndFill()
{
    \fI/* If the object in the avatar's hand is an empty container, tell the
       host to fill it up and update our state info accordingly. */\fC
    if (goTo()) {
        if (isEmptyContainer(avatar.inHand)) {
            @ avatar.inHand!FILL () \(-> (success)
            if (success) {
                self.filled = TRUE
                avatar.action = FILL
            }
        }
    }
}

goToAndGet()
{
    \fI/* Pick object up, put in hand. */\fC
    if (holding(self)) {
        return(TRUE)
    } else if (goTo()) {
        return(get(self))
    } else {
        return(FALSE)
    }
}

goToAndPickFrom()
{
    \fI/* General routine to pick stuff up out of containers */\fC
    if (goTo()) {
        get(pickObject(self.contents))
    }
}

goToAndPickFromIfOpen()
{
    \fI/* General routine to pick stuff up out of open/closable containers. */\fC
    if (goTo()) {
        if (self.open) {
            get(pickObject(self.contents))
        }
    }
}

goToAndPickFromOrGet()
{
    if (!holding(self)) {
        if (goTo()) {
            if (self.open) {
                get(pickObject(self.contents))
            }
        }
    } else {
        get(self)
    }
}

goToCursor()
{
    \fI/* Go to location designated by the cursor. */\fC
    goXY(cursorX, cursorY)
}

goToCursorAndDropAt()
{
    \fI/* Put hand-held item at cursor location. */\fC
    if (goToCursor()) {
        dropAt()
    }
}

goToOrPassThrough()
{
    \fI/* If adjacent, go through (opening/closing as needed), else goto. */\fC
    haveKey = (holdingClass(KEY_CLASS) && avatar.inHand.keyNumber == self.key)
    if (adjacent(self)) {
        if (self.open || self.unlocked || haveKey) {
            return(goXY(oppositeX(self.x), oppositeY(self.y)))
        } else {
            return(FALSE)
    } else {
        return(goTo())
    }
}

goXY(x, y)
{
    \fI/* Walk to a particular (x, y) location, if you can. */\fC
    @ avatar!WALK (x, y) \(-> (destinationX, destinationY)
    avatar.x = destinationX
    avatar.y = destinationY
    \fI/* If we couldn't walk anywhere, the destination coordinates will be
       the same as our current location, and the WALKING activity will
       terminate immediately */\fC
    avatar.activity = WALKING
    return (destinationX == x && destinationY == y)
}

hangUp()
{
    \fI/* Hang up the phone. */\fC
    soundEffect(SOUND_THUMP)
    @ self!HANG () \(-> ()
    self.state = PHONE_READY
    soundEffect(SOUND_SILENCE)
    avatar.action = HANGUP
}

hangUpOrAnswer(okToProceed) 
{
    \fI/* If test passed, hang up phone if not already hung up.  Answer if
       ringing.  Otherwise, depends. */\fC
    if (okToProceed) {
        if (self.state == PHONE_OFF_HOOK || self.state == PHONE_TALKING ||
                self.state == PHONE_LINE_BUSY || self.state ==
                PHONE_LINE_RING) {
            if ((self.state == PHONE_LINE_BUSY || self.state ==
                    PHONE_LINE_RING) && self.class == PHONE_BOOTH_CLASS) {
                soundEffect(SOUND_JANGLE)
                refund(PHONE_CALL_COST, avatar)
            }
            hangUp()
        } else if (self.state == PHONE_RINGING) {
            answer(self)
        }
    } else {
        depends()
    }
}

here(object)
{
    \fI/* Test if object is here.  To be here, object must be where the avatar
       is but not on the avatar's person. */\fC
    return(object.container == region && object.x == avatar.x &&
        object.y == avatar.y)
}

holding(object)
{
    \fI/* Return \fCTRUE\fP iff the avatar is holding the given object. */\fC
    return(avatar.inHand == object)
}

holdingClass(class)
{
    \fI/* Return TRUE iff the avatar is holding an object of class \fCclass\fP */\fC
    return(!emptyHanded(avatar) && avatar.inHand.class == class)
}

load(object)
{
    \fI/* Compute the load inside \fCobject\fP, i.e., how many things it
       is holding. */\fC
    result = 0
    for (i=0; i<(lookupClass(object.class).capacity; ++i) {
        if (object.contents[i] != NULL) {
            result++
        }
    }
    return(result);
}

lookupClass(classNumber)
{
    \fI/* Return the class descriptor associated with the given class
       number. */\fC
    \fB/* In Ron's database code. */\fC
}

mediumExplosion()
{
    \fI/* When items of major magic or explosive content are destroyed. */\fC
    explosionAt(self.x, self.y, MEDIUM_EXPLOSION)
}

nearestAdjacentX(x)
{
    \fI/* Return X coordinate of nearest adjacent location to object. */\fC
    if (avatar.x == x) {
        return(x)
    } else if (avatar.x < x) {
        return(x-1)
    } else {
        return(x+1)
    }
}

nearestAdjacentY(y)
{
    \fI/* Return Y coordinate of nearest adjacent location to object. */\fC
    if (avatar.y == y) {
        return(y)
    } else if (avatar.y < y) {
        return(y-1)
    } else {
        return(y+1)
    }
}

noEffect()
{
    \fI/* Action when nothing happens. */\fC
    return
}

nullDestroy()
{
    \fI/* Do nothing destruction. */\fC
    return
}

nullInit()
{
    \fI/* Do nothing initialization. */\fC
    return
}

openClose()
{
    \fI/* Open or close a door or gate, using key if neccessary. */\fC
    haveKey = (holdingClass(KEY_CLASS) && avatar.inHand.keyNumber == self.key)
    if (!self.open && (haveKey || self.unlocked)) {
        @ self!OPEN () \(-> (success)
        if (success) {
            self.open = TRUE
            self.unlocked = TRUE
            avatar.action = OPEN
        }
    } else if (self.open) {
        @ self!CLOSE () \(-> (success)
        if (success) {
            self.open = FALSE
            if (haveKey) {
                self.unlocked = FALSE
            }
            avatar.action = CLOSE
        }
    } else {
        soundEffect(SOUND_THUMP)
    }
}

openCloseContainer()
{
    \fI/* Open or close a container, using key if neccessary. */\fC
    haveKey = (holdingClass(KEY_CLASS) && avatar.inHand.keyNumber == self.key)
    if (!self.open && (haveKey || self.unlocked)) {
        @ self!OPENCONTAINER () \(-> (success, \fIcontentsVector\fC)
        if (success) {
            unpackContentsVector(self, \fIcontentsVector\fC)
            self.open = TRUE
            self.unlocked = TRUE
            avatar.action = OPEN_CONTAINER
        }
    } else if (self.open) {
        @ self!CLOSECONTAINER () \(-> (success)
        if (success) {
            purgeContents(self)
            self.open = FALSE
            if (haveKey) {
                self.unlocked = FALSE
            }
            avatar.action = CLOSE_CONTAINER
        }
    }
}

oppositeX(x)
{
    \fI/* Return the X coordinate on the opposite side of X from the
       avatar. */\fC
    if (avatar.x == x) {
        return(x)
    } else if (avatar.x < x) {
        return(x+1)
    } else {
        return(x-1)
    }
}

oppositeY(y)
{
    \fI/* Return the Y coordinate on the opposite side of Y from the
       avatar. */\fC
    if (avatar.y == y) {
        return(y)
    } else if (avatar.y < y) {
        return(y+1)
    } else {
        return(y-1)
    }
}

payCoinOpOrDrop(cost, soundCoinDrop, soundSucceed, soundFail, goFunction)
{
    \fI/* Handle coin operated devices.  Take the money, if you can, make the
       appropriate sounds, and return a boolean that tells whether or not we
       were successful in getting the device to operate. */\fC
    if (goFunction()) {
        if (holdingClass(TOKEN_CLASS)) {
            if (avatar.inHand.denomination >= cost) {
                soundEffect(soundCoinDrop)
                @ self!PAY () \(-> (success, \fItext\fC)
                avatar.action = PAY
                if (success) {
                    spend(cost)
                    soundEffect(soundSucceed)
                    return(TRUE)
                } else {
                    soundEffect(soundFail)
                    return(FALSE)
                }
            }
        } else {
            dropAt()
        }
    }
    return(FALSE)
}

payMe(amount)
{
    if (emptyHanded(avatar)) {
        createObject(TOKEN_CLASS, avatar, NULL, HAND)
        avatar.inHand.denomination = amount
    } else if (holdingClass(TOKEN_CLASS) {
        avatar.inHand.denomination += amount
    } else {
        newObject = createObject(TOKEN_CLASS, region, avatar.x, avatar.y)
        newObject.denomination = amount
    }
}

playMusic(\fIscore\fC)
{
    \fB/* *** Start up the sound driver playing the sequence of musical notes
       denoted by \fIscore\fP *** */\fC
}

playSpeech(\fItext\fC)
{
    \fB/* *** Start up the sound driver playing the ``speech'' denoted by
       \fItext\fP. *** */\fC
}

putInto(container, posX, posY, action)
{
    \fI/* Put the object in the avatar's hand into the specified container at
       the specified location in the specified manner. */\fC
    if (emptyHanded(avatar) && load(container) < lookupClass(container.class).
            capacity) {
        @ avatar.inHand!PUT (container.noid, posX, posY) \(-> (success)
        if (success) {
            avatar.action = action
            subjectObject = avatar.inHand
            changeContainers(avatar.inHand, container, posX, posY)
        }
    }
}

pickObject(contentsList)
{
    \fB/* *** Pop into rummage mode, rummaging among the items in
       \fCcontentsList\fP, let the player pick one object (or delve deeper as
       suits him), and return a pointer to this object. *** */\fC
}

purgeContents(object)
{
    \fI/* Remove all knowledge of the contents of \fCobject\fP. */\fC
    for (i=0; i<(lookupClass(object.class).capacity; ++i) {
        purgeContents(object.contents[i])
        destroyObject(object.contents[i])
        object.contents[i] = NULL
    }
}

refund(amount, client)
{
    \fI/* Give some money back in hand. */\fC
    if (emptyHanded(client)) {
        createObject(TOKEN_CLASS, client, NULL, HAND)
        client.inHand.denomination = amount
    } else if (client.inHand.class == TOKEN_CLASS) {
        client.inHand.denomination += amount
    } else {
        newToken = createObject(TOKEN_CLASS, region, client.x, client.y)
        newToken.denomination = amount
    }
}

remove()
{
    \fI/* If wearing, take off, else go and drop. */\fC
    if (wearing(self)) {
        if (emptyHanded(avatar)) {
            changeContainer(self, avatar, NULL, HAND)
            avatar.action = undress
        }
    } else if (holding(self)) {
        dropHere()
    } else {
        goToAndDropAt()
    }
}

sendMail(checkAddress)
{
    \fI/* If avatar is carrying a letter (i.e., a piece of paper with
       (presumably) an address and a message on it) it is taken from the
       avatar's hand and mailed away.  If carrying anything else, it is
       dropped in front of the mailbox. */\fC
    if (holdingClass(PAPER_CLASS) && (checkAddress==NO_ADDRESS_CHECK ||
                self.address==avatar.address) {
        if (goTo()) {
            @ self!SENDMAIL (avatar.inHand.noid, avatar.inHand.\fItext\fC) \(-> ()
            destroyObject(avatar.inHand)
        }
    } else {
        goToAndDropAt()
    }
}

setDownOrGetUp(posture)
{
    \fI/* If sitting in seat, stand up.  If standing up, sit down if you can.
       Handles multiple place seating (couch, hot tub, etc.). */\fC
    \fB/* *** should reflect slot pointed to; add host interaction *** */\fC
    for (i=0; i<selfClass.maxOccupants; ++i) {
        if (self.occupants[i] == NULL) {
            theSlot = i
        } else if (self.occupants[i] == avatar) {
            theSlot = i
            break
        }
    }
    if (adjacent(self) && i!=selfClass.maxOccupants) {
        if (goOnto()) {
            avatar.activity = posture
            self.occupants[theSlot] = avatar
        }
    } else if (here(self)) {
        if (goPreferred()) {
            avatar.activity = STANDING
            self.occupants[theSlot] = NULL
        }
    } else {
        depends()
    }
}

shoot()
{
    \fI/* Attack somebody or something with a firearm. */\fC
    if (!self.safetyOn) {
        soundEffect(SOUND_BANG)
        avatar.action = SHOOT
        if (target.class == AVATAR_CLASS) {
            @ self!ATTACK (target.noid) \(-> (damage)
            soundEffect(SOUND_ATTACK)
            damageAvatar(target, damage)
        } else {
            @ self!BASH (target.noid) \(-> (success)
            soundEffect(SOUND_BASH)
            if (success) {
                destroyObjectDramatically(target)
            }
        }
    } else {
        soundEffect(SOUND_DUD)
    }
}

sitOrGetUp()
{
    \fI/* If sitting in seat, stand up.  If standing up, sit down if you can. */\fC
    setDownOrGetUp(SITTING)
}

smallExplosion()
{
    \fI/* When items of minor magic or volatile content are destroyed. */\fC
    explosionAt(self.x, self.y, SMALL_EXPLOSION)
}

smallExplosionIfMagic()
{
    \fI/* Certain items are only sometimes magical, and only the magical ones
       explode when you destroy them. */\fC
    if (self.magic) {
        smallExplosion()
    } else {
        smash()
    }
}

smash()
{
    \fI/* When ordinary items are destroyed. */\fC
    explosionAt(self.x, self.y, SMASH_UP)
}

smashWithContents()
{
    \fI/* When a container is destroyed, we have to destroy the stuff in it
       to, so if it is carrying a explodable that should explode. */\fC
    for (i=self.contents; i!=NULL; i=i->next) {
        (i.destroy)()
    }
    smash()
}

soundEffect(sound)
{
    \fI/* Emit a particular sound. */\fC
    \fB/* In Randy's sound driver code. */\fC
}

spend(amount)
{
    \fI/* Spend some number of tokens out of hand. */\fC
    avatar.inHand.denomination -= amount
    if (avatar.inHand.denomination == 0) {
        destroyObject(avatar.inHand)
    }
}

strike()
{
    \fI/* Attack somebody or something with a close-range melee weapon. */\fC
    if (!elsewhere(target)) {
        avatar.action = STRIKE
        subjectObject = self
        targetObject = target
        if (target.class == AVATAR_CLASS) {
            @ self!ATTACK (target.noid) \(-> (damage)
            soundEffect(SOUND_ATTACK)
            damageAvatar(target, damage)
        } else {
            @ self!BASH (target.noid) \(-> (success)
            soundEffect(SOUND_BASH)
            if (success) {
                destroyObjectDramatically(target)
            }
        }
    }
}

textEdit(paper)
{
    \fB/* *** Pop into text editor mode to view and edit the text on
       \fCpaper\fP. *** */\fC
}

textEditReadOnly(\fItext\fC)
{
    \fB/* *** Pop into text editor mode to view \fItext\fP, but don't let the
       player alter what he sees. *** */\fC
}

throw()
{
    \fI/* Throw hand-held item at object's location.  Throw is called from
       under a \fBreversed-do\fI, so the we are now the object being thrown,
       and target tells us the destination.  It is rather like \fCdrop\fI,
       except we don't know for sure where the object will land until the host
       tells us, and hitting something can do damage. */\fC
    @ self!THROW (target.noid) \(-> (newTarget, newX, newY, hit)
    avatar.action = THROW
    subjectObject = self
    changeContainers(self, newTarget, newX, newY)
    if (hit) {
        soundEffect(SOUND_HIT)
        \fB/* *** effect of hit? *** */\fC
    }
}

toggleSwitch(okToProceed)
{
    \fI/* Turn the object on or off. */\fC
    if (okToProceed) {
        if (self.on) {
            self.on = FALSE
            @ self!OFF () \(-> ()
            soundEffect(SOUND_OFF)
        } else {
            self.on = TRUE
            @ self!ON () \(-> ()
            soundEffect(SOUND_ON)
        }
        return(TRUE)
    } else {
        return(FALSE)
    }
}

unpackContentsVector(object, \fIcontentsVector\fC)
{
    \fI/* Decode \fIcontentsVector\fP as the new contents of the given
       object. */\fC
    \fB/* In Randy's communications code. */\fC
}

wear()
{
    \fI/* If holding, put it on.  If not, go get it. */\fC
    if (!wearing(self)) {
        if (!holding(self)) {
            goToAndGet()
        } else {
            changeContainer(self, avatar, NULL, selfClass.location)
            avatar.action = WEAR
        }
    }
}

wearing(clothing)
{
    \fI/* Return true if avatar is wearing the item of clothing. */\fC
    return(amongContents(clothing, avatar))
}

wearOrUnpocket()
{
    \fI/* If wearing, remove item from pockets, else wear. */\fC
    if (!wearing(self)) {
        wear()
    } else {
        get(pickObject(self.contents))
    }
}

writeTo(paper, \fItext\fC)
{
    \fI/* Add the given text to the text on \fCpaper\fP. */\fC
    paper.text = concatenateStrings(paper.text, \fItext\fC)
}


ANSWER* (avatar, success)
{
    avatar.action = UNHOOK
    if (success) {
        self.state = PHONE_TALKING
        soundEffect(SOUND_SILENCE)
    } else {
        soundEffect(SOUND_LINE_THUMP)
        if (self.class == PHONE_BOOTH_CLASS) {
            self.state = PHONE_OFF_HOOK
        } else {
            self.state = PHONE_ACTIVE
        }
        soundEffect(SOUND_DIAL_TONE)
    }
}

ANSWERED* ()
{
    self.state = PHONE_TALKING
    soundEffect(SOUND_SILENCE)
}

DIAL* (success)
{
    if (success) {
        self.state = PHONE_LINE_RING
        soundEffect(SOUND_LINE_RING)
    } else {
        self.state = PHONE_LINE_BUSY
        soundEffect(SOUND_LINE_BUSY)
    }
}

DRIVE* (x, y)
{
    \fI/* Asynchronous function when directed to move to another location and
       traveling in a powered vehicle. */\fC
    self.targetX = x
    self.targetY = y
    self.moving = TRUE
    soundEffect(SOUND_ENGINE)
}

HANG* ()
{
    if (self.class == PHONE_BOOTH_CLASS && (self.state == PHONE_LINE_BUSY ||
            self.state == PHONE_LINE_RING)) {
        soundEffect(SOUND_JANGLE)
        refund(PHONE_CALL_COST, self.container)
    }
    soundEffect(SOUND_THUMP)
    soundEffect(SOUND_SILENCE)
    self.state = PHONE_READY
    self.container.action = HANGUP
}

HUNGUP* ()
{
    \fI/* Asynchronous message from host when the party at the other end hangs
       up.  If we have answered we should get disconnected.  If we have not,
       then the phone should just stop ringing */\fC
    if (self.state == PHONE_TALKING) {
        soundEffect(SOUND_LINE_THUMP)
        if (self.class == PHONE_BOOTH_CLASS) {
            self.state = PHONE_OFF_HOOK
        } else {
            self.state = PHONE_ACTIVE
        }
        soundEffect(SOUND_DIAL_TONE)
    } else {
        self.state = PHONE_READY
        soundEffect(SOUND_SILENCE)
    }
}

OFF* ()
{
    self.on = FALSE
}

OFFLIGHT* ()
{
    self.on = FALSE
    lightLevel--
}

ON* ()
{
    self.on = TRUE
}

ONLIGHT* ()
{
    self.on = TRUE
    lightLevel++
}

ORACLESPEAK+ (\fItext\fC)
{
    \fI/* Asynchronous message from host when an oracle says something */\fC
    \fB/* *** Trigger this. *** */\fC
    balloonMessage(self, "%s", \fItext\fC)
}

RING* ()
{
    \fI/* Asynchronous message from host when the phone should ring.  Host
       makes sure we don't get this happening when the phone is not ready, so
       it *should* be safe to assume that the phone is in the PHONE_READY
       state */\fC
    self.state = PHONE_RINGING
    soundEffect(SOUND_BELL_RING)
}

SPEAK* (\fItext\fC)
{
    \fI/* Asynchronous message from host when player somebody says
       something. */\fC
    balloonMessage(self, "%s", \fItext\fC)
}

UNHOOK* (avatar)
{
    if (self.class == PHONE_BOOTH_CLASS) {
        self.state = PHONE_OFF_HOOK
    } else {
        self.state = PHONE_READY
    }
    avatar.action = UNHOOK
    soundEffect(SOUND_CLICK_CLUNK)
    soundEffect(SOUND_DIAL_TONE)
}

WALK* (x, y)
{
    \fI/* Asynchronous function when directed to move to another location. */\fC
    self.targetX = x
    self.targetY = y
    self.moving = TRUE
    self.activity = WALKING
}
.fi
.SH
\s+3Host System Standard Actions and Functions\s-3
.ds LH HOST SYSTEM FUNCTIONS
.PP
The home system object behavior code includes messages to the host which
direct certain actions.  The below functions are shared among several
different classes of objects and so are collected here, rather than with the
descriptions of the objects themselves.
.LP
.nf
\fCANSWER () \(-> (success)
{
    if (!elsewhere(self) && self.state == PHONE_RINGING) {
        if (self.caller != NULL) {
            self.state = PHONE_TALKING
            self.caller.state = PHONE_TALKING
            talker = avatar
            success = TRUE
            # self \(-> ANSWER* (avatar.noid, TRUE)
            self.caller \(-> ANSWERED* ()
        } else {
            success = FALSE
        }
    } else {
        success = FALSE
    }
}

ASKORACLE (\fItext\fC) \(-> ()
{
    if (self.live) {
        askQuestionLive(\fItext\fC)
    } else {
        newQuestion = alloc(QUESTION_ENTRY)
        newQuestion->question = \fItext\fC
        newQuestion->previousQuestion = self.questions
        self.questions = newQuestion
    }
}

ATTACK (targetId) \(-> (damage)
{
    target = \(uatargetId
    \fB/* *** handle path check on ranged weapons *** */\fC
    if ((!elsewhere(target) || isRangedWeapon(self)) && target.class ==
            AVATAR_CLASS) {
        damage = damageAvatar(target, self)
        # avatar \(-> ATTACK* (targetId, damage)
    } else {
        damage = 0
    }
}

BASH (targetId) \(-> (success)
{
    target = \(uatargetId
    \fB/* *** handle path check on ranged weapons *** */\fC
    if ((!elsewhere(target) || isRangedWeapon(self)) && target.class !=
            AVATAR_CLASS) {
        success = damageObject(target, self)
        # avatar \(-> BASH* (targetId, success)
    } else {
        success = FALSE
    }
}

CLOSE () \(-> (success)
{
    haveKey = (holdingClass(KEY_CLASS) && avatar.inHand.keyNumber == self.key)
    if (!elsewhere(self) && self.open) {
        success = TRUE
        self.open = FALSE
        self.unlocked = !haveKey
        # avatar \(-> CLOSE* (self, self.unlocked)
    } else {
        success = FALSE
    }
}

CLOSECONTAINER () \(-> (success)
{
    haveKey = (holdingClass(KEY_CLASS) && avatar.inHand.keyNumber == self.key)
    if (!elsewhere(self) && self.open) {
        disappearContents(self)
        self.open = FALSE
        self.unlocked = !haveKey
        # avatar \(-> CLOSECONTAINER* (self, self.unlocked)
        success = TRUE
    } else {
        success = FALSE
    }
}

DIAL (\fItext\fC) \(-> (success)
{
    success = FALSE
    if (!elsewhere(self) && self.state == PHONE_ACTIVE) {
        self.talker = avatar
        self.caller = lookupPhoneNumber(\fItext\fC)
        if (self.caller != NULL) {
            if (self.caller.state == PHONE_READY) {
                self.caller.state = PHONE_RINGING
                self.caller.caller = self
                self.state = PHONE_LINE_RING
                self.caller \(-> RING* ()
                if (self.caller.owner.container != self.caller.container) {
                    if (self.caller.beeper != NULL) {
                        self.caller.beeper \(-> BEEP* ()
                    }
                    if (self.caller.answeringMachine != NULL) {
                        answerPhoneWithMachine(self.caller.answeringMachine)
                    }
                }
                success = TRUE
            } else {
                self.state = PHONE_LINE_BUSY
            }
        } else {
            success = FALSE
        }
        # self \(-> DIAL* (success)
    } else {
        success = FALSE
    }
}

GET () \(-> (success)
{
    if (emptyHanded(avatar) && accessible(self)) {
        changeContainers(self, avatar, NULL, HAND)
        if (self.class == BEEPER_CLASS) {
            avatar.homePhone.beepr = self
        } else if (self == avatar.homePhone.answeringMachine) {
            avatar.homePhone.answeringMachine = NULL
        }
        success = TRUE
        # avatar \(-> GET* (self.noid)
    } else {
        success = FALSE
    }
}

HANG () \(-> ()
{
    if (!elsewhere(self) && self.state != PHONE_READY) {
        self.state = PHONE_READY
        talker = NULL
        if (self.caller != NULL) {
            self.caller.caller = NULL
            self.caller \(-> HUNGUP* ()
        }
        # self \(-> HANG* ()
        self.caller = NULL
    }
}

MAGIC () \(-> ()
{
    (*magicBehavior[self.magicType])() \fB/* *** expand *** */\fC
}

OFF () \(-> ()
{
    if (!elsewhere(self) && self.on) {
        self.on = FALSE
        # self \(-> OFF* ()
    }
}

OFFPLAYER () \(-> ()
{
    if (!elsewhere(self) && self.on) {
        self.on = FALSE
        # self \(-> OFF* ()
        dequeuePlayer(self)
    }
}

ON () \(-> ()
{
    if (!elsewhere(self) && !self.on) {
        self.on = TRUE
        # self \(-> ON* ()
    }
}

ONPLAYER () \(-> ()
{
    if (!elsewhere(self) && !self.on) {
        self.on = TRUE
        # self \(-> ON* ()
        enqueuePlayer(self)
    }
}

OPEN () \(-> (success)
{
    haveKey = (holdingClass(KEY_CLASS && avatar.inHand.keyNumber == self.key)
    if (!elsewhere(self) && !self.open && (haveKey || self.unlocked)) {
        self.open = TRUE
        self.unlocked = TRUE
        success = TRUE
        # avatar \(-> OPEN* (self)
    } else {
        success = FALSE
    }
        
}

OPENCONTAINER () \(-> (success, \fIcontentsVector\fC)
{
    haveKey = (holdingClass(KEY_CLASS) && avatar.inHand.keyNumber == self.key)
    if (!elsewhere(self) && !self.open && (haveKey || self.unlocked)) {
        \fIcontentsVector\fC = vectorize(self.contents)
        self.open = TRUE
        self.unlocked = TRUE
        success = TRUE
        # avatar \(-> OPENCONTAINER* (self, \fIcontentsVector\fC)
    } else {
        success = FALSE
        \fIcontentsVector\fC = ""
    }
}

PUT (containerId, posX, posY) \(-> (success)
{
    container = \(uacontainerId
    if (holding(self) && available(container, posX, posY) && load(container) <
            lookupClass(container.class).capacity) {
        changeContainers(self, container, posX, posY)
        success = TRUE
        # avatar \(-> PUT* (self.noid, containerId, posX, posY)
        if (self.class == BEEPER_CLASS) {
            avatar.homePhone.beeper = NULL
        } else if (self.class == ANSWERING_MACHINE_CLASS) {
            if (self.container == avatar.homePhone.container) {
                avatar.homePhone.answeringMachine = self
            }
        }
    } else {
        success = FALSE
    }
}

SENDMAIL (paperId, \fItext\fC) \(-> ()
{
    paper = \(uapaperId
    if (paper.class == PAPER_CLASS) {
        sendMailMessage(\fItext\fC)
        destroyObject(paper)
    }
}

TALK (\fItext\fC) \(-> ()
{
    if (!elsewhere(self) && self.state == PHONE_ACTIVE && self.caller != NULL) {
        self.caller \(-> SPEAK* (\fItext\fC)
    }
}

THROW (targetId) \(-> (newTarget, newX, newY, hit)
{
    target = \(uatargetId
    if (holding(self)) {
        checkPath(target, target.x, target.y, &newX, &newY)
        hit = (newX == target.x && newY == target.y)
        if (hit) {
            newTarget = targetId
            # avatar \(-> THROW* (targetId, newX, newY, hit)
        } else {
            newTarget = region.noid
            # avatar \(-> THROW* (region.noid, newX, newY, hit)
        }
    } else {
        newX = self.x
        newY = self.y
        hit = FALSE
    }
}

UNHOOK () \(-> ()
{
    if (!elsewhere(self) && self.state == PHONE_READY) {
        if (self.class == PHONE_BOOTH_CLASS) {
            self.state = PHONE_OFF_HOOK
        } else {
            self.state = PHONE_ACTIVE
        }
        # self \(-> UNHOOK* (avatar.noid)
    }
}

accessible(object)
{
    \fB/* *** Return \fCTRUE\fP if avatar can get \fCobject\fP.  Needs, among
       other things, to handle interlock used for countertop and display
       case. *** */\fC
}

alloc(type)
{
    \fI/* Allocate storage for an entity of the given type, and return a
       pointer to this storage. */\fC
    \fB/* Built into PL/1. */\fC
}

announceObject(object)
{
    \fB/* *** Announce the existence of \fCobject\fP and its state to
       everybody in the region except the ourselves. *** */\fC
}

answerPhoneWithMachine(phone, machine)
{
   \fB/* *** Somebody is trying to call \fCphone\fP, but nobody's home, so
       have \fCmachine\fP answer, play its message, and take a message from
       the caller. *** */\fC
}

askQuestionLive(\fItext\fC)
{
    \fB/* Send \fItext\fP to the system person currently playing
       oracle. *** Ask JH *** */\fC
}

atWater()
{
    \fB/* *** Return \fCTRUE\fP if there is water at the avatar's present
       location. *** */\fC
}

available(container, x, y)
{
    \fI/* Return \fCTRUE\fP if there is not already an object occupying
       the given (x,y) location inside \fCcontainer\fP. */\fC
    return(container.contents[y] == NULL)
}

cancelEvent(eventId)
{
    \fB/* Cancel the previously scheduled event indicated by
       \fCeventId\fP. *** Ask JH *** */\fC
}

changeContainers(object, newContainer, newX, newY)
{
    \fI/* Move \fCobject\fI from wherever it is now to the indicated
       (x, y) location in the indicated new container. */\fC
    object.container.contents[object.y] = NULL
    object.container = newContainer
    object.x = newX
    object.y = newY
    newContainer.contents[newY] = object
}

checkPath(target, x, y, newx, newy)
{
    \fB/* Check for a path from the avatar's present location to the
       object \fCtarget\fP at the given (x,y) location in the region.  Set
       \fCnewx\fP and \fCnewy\fP to the (x,y) location of the farthest point
       from the avatar along that path which can be reached in a straight line
       (of course, if the way is completely clear, \fCnewx=x\fP and
       \fCnewy=y\fP. *** Discuss with JH *** */\fC
}

createObject(class, container, x, y)
{
    \fB/* Create and object of the specified class located at the given
       (x,y) location within the given container.  Return a pointer to the new
       instance descriptor. *** Ask JH *** */\fC
}

damageAvatar(who, damage)
{
    \fB/* *** When an avatar is injured, subtract \fCdamage\fP from his health
       and apply the appropriate effects accordingly. *** */\fC
}

damageObject(object, weapon)
{
    \fB/* *** Return \fCTRUE\fP iff attacking \fCobject\fP with \fCweapon\fP
       damages it. *** */\fC
}

dequeuePlayer(player)
{
    \fB/* Remove the given player object (radio or tape deck) from the
       queue of things receiving PLAY+() messages. *** Ask JH *** */\fC
}

destroyContents(object)
{
    \fI/* Destroy all the objects that \fCobject\fP contains. */\fC
    for (i=0; i<(lookupClass(object.class).capacity; ++i) {
        destroyObject(object.contents[i])
        object.contents[i] = NULL
    }
}

destroyObject(object)
{
    \fB/* Destroy the given object.  I.e., delete it and garbage collect
       all its resources. *** Ask JH *** */\fC
}

disappearContents(container)
{
    \fB/* *** As far as the players are concerned, delete all the objects
       contained in \fCcontainer\fP.  As far as we are concerned, these
       objects continue to exist. *** */\fC
}

disappearObject(object)
{
    \fB/* *** As far as the players are concerned, delete \fCobject\fP.  As
       far as we are concerned, it continues to exist. *** */\fC
}

elsewhere(object)
{
    \fI/* Test if object is elsewhere.  To be elsewhere, object must be
       neither where the avatar is nor adjacent to him nor on his person. */\fC
    return(!here(object) && !adjacent(object) && object.container!=avatar)
}

emptyHanded(who)
{
    \fI/* Return \fCTRUE\fP iff the avatar is not holding anything. */\fC
    return(who.inHand == NULL)
}

enqueuePlayer(player)
{
    \fB/* Add the given player (radio or tape deck) to the queue of things
       that need to be send PLAY+() messages every so often. *** Ask JH *** */\fC
}

holding(object)
{
    \fI/* Return \fCTRUE\fP iff the avatar is holding the given object. */\fC
    return(avatar.inHand == object)
}

holdingClass(class)
{
    \fI/* Return TRUE iff the avatar is holding an object of class \fCclass\fP */\fC
    return(!emptyHanded(avatar) && avatar.inHand.class == class)
}

goToNewRegion(avatar, region)
{
    \fB/* Transport \fCavatar\fP to region \fCregion\fP. *** Ask JH *** */\fC
}

isRangedWeapon(object)
{
    \fB/* *** Return \fCTRUE\fP iff \fCobject\fP is a ranged weapon (e.g., a
       gun). *** */\fC
}

load(object)
{
    \fI/* Compute the load inside \fCobject\fP, i.e., how many things it
       is holding. */\fC
    result = 0
    for (i=0; i<(lookupClass(object.class).capacity; ++i) {
        if (object.contents[i] != NULL) {
            result++
        }
    }
    return(result);
}

lookupClass(classNumber)
{
    \fI/* Return the class descriptor associated with the given class
       number. */\fC
    \fB/* *** Ask JH *** */\fC
}

lookupPhoneNumber(\fItext\fC)
{
    \fB/* *** Try to interpret \fCtext\fP as a phone number and return a
       pointer to the telephone object that the number corresponds to.
       (NULL if there is none.) *** */\fC
}

lookupSelection(musicList, listLength, \fItext\fC)
{
    \fB/* *** \fCText\fP is a jukebox selection.  Figure out which piece in
       \fCmusicList\fP it is and return a pointer to it. *** */\fC
}

lookupTeleportAddress(\fItext\fC)
{
    \fB/* *** Try to interpret \fCtext\fP as a teleport number and return a
       pointer to the teleport object that the number corresponds to.
       (NULL if there is none.) *** */\fC
}

payMe(amount)
{
   \fI/* Pay the given amount to the avatar. */\fC
   payTo(avatar, amount)
}

payTo(player, amount)
{
    \fI/* Pay the given amount to the designated player. */\fC
    if (emptyHanded(player)) {
        createObject(TOKEN_CLASS, player, NULL, HAND)
        player.inHand.denomination = actualWithdrawal
        announceObject(player.inHand)
    } else if (player.inHand.class == TOKEN_CLASS) {
        player.inHand.denomination += actualWithdrawal
    } else {
        newObject = createObject(TOKEN_CLASS, region, player.x, player.y)
        newObject.denomination = actualWithdrawal
        announceObject(newObject)
        }
    }
}

random()
{
    \fB/* Return a random integer. *** Ask JH *** */\fC
}

randomTimeInTheFuture()
{
    \fB/* *** Return some random time in the future. *** */\fC
}

scheduleEvent(eventProcedure, delay)
{
    \fB/* Set things up so that the procedure \fCeventProcedure\fP will be
       called \fCdelay\fP time units from now.  Return an identifier of some
       sort so we can cancel this in the future if we so desire.
       *** Ask JH *** */\fC
}

sendMailMessage(\fItext\fC)
{
    \fB/* Interpret \fItext\fP as a mail message and send it off.  We
       extract the address from the text itself. *** Ask JH *** */\fC
}

spend(cost)
{
    \fI/* Have the avatar spend the given amount out of pocket or bank
       account, if he can.  Return a boolean indicating how successful this
       was. */\fC
    if (holdingClass(TOKEN_CLASS) && avatar.inHand.denomination >= cost) {
        avatar.inHand.denomination -= cost
        if (avatar.inHand.denomination == 0) {
            destroyObject(avatar.inHand)
        }
        return(TRUE)
    } else if (holdingClass(CREDIT_CARD_CLASS) && avatar.bankAccountBalance >=
            cost) {
        avatar.bankAccountBalance -= cost
        return(TRUE)
    } else {
        return(FALSE)
    }
}

vectorize(contentsList)
{
    \fB/* Take the given contents list and turn it into a byte vector
       suitable for transmission to the players. *** Ask JH *** */\fC
}
.fi
.SH
\s+3The Objects\s-3
.ds LH THE OBJECTS
.PP
The object descriptions follow on the proceeding pages:
.bp
.Ob
amulet
.De
A hang-around-the neck type amulet.
.Fu
Generic magic talisman.
.No
Amulets are always magical.  An amulet will do something special and powerful.
The magical function may vary. \fB*** The set of magical functions needs
thought. ***\fP  Amulets are particularly rare and contain unusually powerful
forms of magic.  The general function of an amulet will be to confer some
particular power or ability on the avatar wearing it.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
location = NECK /* Where on the body this is worn. */
.Hp
magicType       /* What sort of magic this amulet contains.  Used as case
                   switch for execution of magical behavior. */
.Co
.Do
doMagic()
.Go
goTo()
.St
cease()
.Ge
wear()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smallExplosion()
.As
\fRNone.
.Gr
Single static image of amulet sitting by itself.  Cels for amulet around
avatar's neck in front and side views.
.Hb
GET
MAGIC
PUT
THROW
.En
.Ob
answering machine
.De
A telephone answering machine.
.Fu
Handle your phone calls when you're not at home.
.No
The answering machine operates in conjunction with a telephone (of the non-pay
and non-portable variety, of which there may be only one per region).  Most of
the answering machine's guts reside in the host.  The answering machine has a
light on it that is lit if there are messages waiting.
.Sy
\fRNone.
.Pr
waitingMessages /* A flag telling if there are waiting messages.  TRUE if
                   there are. */
.Cl
\fRNo class properties.
.Hp
messageQueue    /* The waiting messages themselves, if there are any, in FIFO
                   order. */
owner           /* The avatar who belongs to this machine. */
.Co
.Do
.nf
{
    \fI/* If there is a message waiting, it is played back.  Note that the
       host will allow only the machine's owner to play the messages. */\fC
    if (!elsewhere(self)) {
        if (self.messageWaiting) {
            @ self!PLAYMESSAGE () \(-> (moreMessages, \fItext\fC)
            self.messageWaiting = moreMessages
            balloonMessage(self, "%s", \fItext\fC)
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
.nf
{
    \fI/* Use the typed text string as the new message on the machine. */\fC
    @ self!SETANSWER (\fItext\fC) \(-> ()
}
.Re
noEffect()
.In
.nf
init(waitingMessages)
{
    self.waitingMessages = waitingMessages
}
.Dy
smash()
.As
TAKEMESSAGE* ()
{
    \fI/* Asynchronous action when a message is taken. */\fC
    \fB/* *** Trigger this. *** */\fC
    self.messagesWaiting = TRUE
}
.Gr
Two state image of the machine: with message light off and with message light
on.
.Hb
GET
PLAYMESSAGE () \(-> (moreMessages, \fItext\fC)
{
    if (self.owner == avatar) {
        if (self.messageQueue->firstMessage != NULL) {
            \fItext\fC = self.messageQueue->firstMessage->\fCtext\fC
            deadMessage = self.messageQueue->firstMessage
            self.messageQueue = self.messageQueue->firstMessage->nextMessage
            garbageCollect(deadMessage)
        } else {
            \fCtext\fC = ""
        }
        moreMessages = (self.messageQueue->firstMessage != NULL)
        if (!moreMessages) {
            self.messageQueue->lastMessage = NULL
        }
    }
}
PUT
SETANSWER (\fItext\fC) \(-> ()
{
    if (self.owner == avatar) {
        newMessage = alloc(MESSAGE_QUEUE_ENTRY)
        newMessage->\fCtext\fC = \fCtext\fC
        newMessage->nextMessage = NULL
        if (self.messageQueue->lastMessage == NULL) {
            self.messageQueue->firstMessage = newMessage
        } else {
            self.messageQueue->lastMessage->nextMessage = newMessage
        }
        self.messageQueue->lastMessage = newMessage
    }
}
.En
.Ob
aquarium
.De
Your basic fish tank.
.Fu
Household decoration.
.No
The aquarium is just a visual joke.
.Sy
\fRNone.
.Pr
state           /* The state that the aquarium is currently in.  The possible
                   states are FISH_SWIMMING, FISH_FEEDING, FISH_DEAD and
                   FISH_GONE. */
.Cl
\fRNo class properties.
.Hp
fishDie         /* Event that will kill off the fish if you don't feed them in
                   time. */
.Do
.nf
{
    \fI/* Feed the fish, if you have the fish food. */\fC
    if (holdingClass(FISH_FOOD_CLASS) && adjacent(self) && self.state ==
            FISH_SWIMMING) {
        @ self!FEED () \(-> ()
        self.state = FISH_FEEDING
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
GoToAndGet()
.Pu
GoToAndDropAt()
.Ta
broadcast
.Re
throw()
.In
.nf
init(state)
{
    self.state = state
}
.Dy
smash()
.As
CHANGESTATE* (newState)
{
    \fI/* Asynchronous message from host when state of fish changes. */\fC
    self.state = newState
}
.Gr
Animation of fish swimming in tank.  Animation of fish feeding.  Static image
of dead fish floating at top of tank.  Static image of empty tank.
.Hb
FEED () \(-> ()
{
    if (holdingClass(FISH_FOOD_CLASS) && adjacent(self) && self.state ==
            FISH_SWIMMING) {
        self.state = FISH_FEEDING
        # self \(-> CHANGESTATE* (self.state)
        cancelEvent(self.fishDie)
        self.fishDie = NULL
        scheduleEvent(FishFed, FISH_FEED_DELAY)
    }
}
FishFed()
{
    self.state = FISH_SWIMMING
    # self \(-> CHANGESTATE* (self.state)
    self \(-> CHANGESTATE* (self.state)
    self.fishDie = scheduleEvent(FishDie, FISH_DEATH_DELAY)
}
FishDie()
{
    self.state = FISH_DEAD
    self.fishDie = NULL
    # self \(-> CHANGESTATE* (self.state)
    self \(-> CHANGESTATE* (self.state)
}
.En
.Ob
atm
.De
\fBA\fPutomatic \fBT\fPoken \fBM\fPachine.
.Fu
Dispenses tokens.
.No
Every player in the \fBMicroCosm\fP has a bank account at the First MicroCosm
Bank & Trust Company.  Money that is in your bank account cannot be taken from
you by force (i.e., it doesn't protect you from blackmail, fraud, etc.).  The
ATM is a device for accessing the account.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
.nf
{
    \fI/* Causes the machine to tell you your account balance */\fC
    balloonMessage(self, "Balance: T%d", bankAccountBalance)
}
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* Takes 50 tokens or your entire balance, whichever is less, from
       your account and puts them in your avatar's hand. */\fC
    if (goTo()) {
        if (bankAccountBalance < 50) {
            withdrawal = bankAccountBalance
        } else {
            withdrawal = 50
        }
        if (withdrawal > 0) {
            @ self!WITHDRAW (withdrawal) \(-> (actualWithdrawal)
            soundEffect(SOUND_WITHDRAW)
            bankAccountBalance -= actualWithdrawal
            balloonMessage(self, "New balance: T%d", bankAccountBalance)
            payMe(actualWithdrawal)
        } else {
            balloonMessage(self, "Insufficient funds")
        }
    }
}
.Pu
.nf
{
    \fI/* If item in hand is tokens, these are deposited in your account and
       disappear from hand, otherwise item is dropped in front of machine */\fC
    if (goTo()) {
        if (holdingClass(TOKEN_CLASS)) {
            @ self!DEPOSIT (avatar.inHand.noid) \(-> ()
            soundEffect(SOUND_DEPOSIT)
            bankAccountBalance += avatar.inHand.denomination
            balloonMessage(self, "New balance: T%d", bankAccountBalance)
            destroyObject(avatar.inHand)
        } else {
            dropAt();
        }
    }
}
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static cel image of machine.  Sound effect of money being withdrawn.
Sound effect of money being deposited.
.Hb
DEPOSIT (tokenId) \(-> ()
{
    token == \(uatokenId
    if (holding(token) && token.class == TOKEN_CLASS) {
        bankAccountBalance += token.denomination
        destroyObject(token)
    }
}
WITHDRAW (withdrawal) \(-> (actualWithdrawal)
{
    if (bankAccountBalance >= withdrawal) {
        actualWithdrawal = withdrawal
    } else {
        actualWithdrawal = bankAccountBalance
    }
    bankAccountBalance -= actualWithdrawal
    if (actualWithdrawal > 0) {
        payTo(avatar, actualWithdrawal);
    }
}
.En
.Ob
avatar
.De
You or somebody else.
.Fu
The animated figure.
.No
The avatar object is one of the keystones of the system.  Everything that
happens is oriented around one or another avatars performing some action.  As
a result, the state information associated with an avatar is quite complex.
.Sy
\fRNone.
.Pr
contents        /* The thing the avatar is wearing or holding.  This is
                   usually not referenced directly, but through the following
                   specific locations (the X position ``inside'' the avatar is
                   used to identify them): */
inHand          /* The object that the avatar has in its hands.  NULL if hands
                   are empty.  This is part of contents, X == 0. */
torso           /* What the avatar is wearing on its torso (shirt, jacket,
                   etc.).  NULL if not wearing anything there.  This is part
                   of contents, X == 1. */
legs            /* What the avatar is wearing on its legs (pants, skirt,
                   etc.). NULL if not wearing anything there.  This is part of
                   contents, X == 2. */
feet            /* What the avatar is wearing on its feet (shoes, boots,
                   etc.).  NULL if not wearing anything there.  This is part
                   of contents, X == 3. */
head            /* What the avatar is wearing on its head (hat, helmet, etc.).
                   NULL if not wearing anything there.  This is part of
                   contents, X == 4. */
activity        /* On-going activity that the avatar is in the midst of
                   (WALKING, SITTING, STANDING, etc.) */
action          /* One-time action that the avatar is executing (JUMP, WAVE,
                   PICKUP, POUR, etc.) */
actionStep      /* What step of the above action the avatar is in. */
orientation     /* What direction the avatar is facing (WEST, EAST, NORTH or
                   SOUTH only). */
health          /* Health of the avatar in the range 0 to 255.  An avatar with
                   a health of 0 is dead. */
restrainer      /* If the avatar is restrained by another avatar, this will
                   tell who the restrainer is.  If not, this will be NULL. */
address         /* Mail address associated with this avatar. */
moving          /* A flag that the avatar is in motion. */
targetX         /* Motion destination X position. */
targetY         /* Motion destination Y position. */
.Cl
\fRNo class properties.
.Hp
accountBalance  /* Balance in the avatar's bank account (in Tokens). */
player          /* Identification of player user-name associated with this
                   avatar. */
turf            /* Region that is the avatar's home turf. */
busFarePaid     /* Flag that avatar has paid to ride the bus. */
homePhone       /* Object that is avatar's home phone. */
.Co
.Do
depends()
.Go
.nf
{
    \fI/* If me, change posture, otherwise, goto. */\fC
    if (avatar == self) {
        if (self.activity == STANDING) {
             self.activity = SITTING
             @ self!POSTURE (SITTING) \(-> ()
        } else if (self.activity == SITTING) {
             self.activity = LAYING
             @ self!POSTURE (LAYING) \(-> ()
        } else {
             self.activity = STANDING
             @ self!POSTURE (STANDING) \(-> ()
        }
    } else {
        goTo()
    }
}
.St
cease()
.Ge
.nf
{
    \fI/* If not me, go to the other avatar and take whatever is in his hands.
       If his hands are empty then grab him and restrain him.  If it is me,
       then no effect. */\fC
    \fI/* Try not to get too confused: in this context \fCavatar\fP is the
       avatar object associated with the player, while \fCself\fP is the
       avatar object being pointed to. */\fC
    if (self != avatar) {
        if (goTo()) {
            if (emptyHanded(avatar)) {
                @ self!GRAB () \(-> (success, grabbedAvatar)
                if (success) {
                    if (!grabbedAvatar) {
                        changeContainers(self.inHand, avatar, NULL, HAND)
                    } else {
                        self.restrainer = avatar
                }
            }
        }
    } else {
        noEffect()
    }
}
.Pu
.nf
{
    \fI/* If not me, go to the other avatar give him whatever is in my hands.
       If it is me, no effect. */\fC
    if (self != avatar) {
        if (goTo()) {
            if (emptyHanded(self)) {
                @ self!HAND () \(-> (success)
                if (success) {
                    changeContainers(avatar.inHand, self, NULL, HAND)
                }
            }
        }
    } else {
        noEffect()
    }
}
.Ta
.nf
{
    \fI/* If not me, text message is sent to other avatar as a
       person-to-person message.  If me, broadcast. */\fC
    if (self != avatar) {
        @ avatar!SPEAK (self.noid, \fItext\fC) \(-> ()
    } else {
        broadcast()
    }
}
.Re
noEffect()
.In
.nf
init(activity, orientation, health, address, moving, targetX, targetY,
        \fIcontentsVector\fC)
{
    self.activity = activity
    self.action = NULL
    self.actionStep = 0
    self.orientation = orientation
    self.health = health
    self.restrainer = NULL
    self.address = address
    self.moving = moving
    self.targetX = targetX
    self.targetY = targetY
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
killAvatar()
.As
ATTACK* (target, damage)
{
    soundEffect(SOUND_ATTACK)
    self.action = STRIKE
    subjectObject = self.inHand
    targetObject = target
    damageAvatar(target, damage)
}
BASH* (target, success)
{
    soundEffect(SOUND_BASH)
    self.action = STRIKE
    subjectObject = self.inHand
    targetObject = target
    if (success) {
        destroyObjectDramatically(target)
    }
}
BUGOUT* ()
{
    soundEffect(SOUND_ZAP)
    escaper = self.inHand
    escaper.charge--
    if (escaper.charge == 0) {
        destroyObject(escaper)
    }
}
CLOSE* (door, unlocked)
{
    door.open = FALSE
    door.unlocked = unlocked
    self.action = CLOSE
}
CLOSECONTAINER* (container, unlocked)
{
    purgeContents(container)
    container.open = FALSE
    container.unlocked = unlocked
    self.action = CLOSE_CONTAINER
}
FILL* ()
{
    self.inHand.filled = TRUE
    self.action = FILL
}
GET* (object)
{
    changeContainers(object, self, NULL, HAND)
    self.action = PICKUP \fB/* *** What if picking from container? *** */\fC
    subjectObject = object
}
GRAB* (avatar)
{
   avatar.restrainer = self
}
GRABFROM* (avatar)
{
    changeContainers(avatar.inHand, self, NULL, HAND)
}
OPEN* (door)
{
    door.open = TRUE
    door.unlocked = TRUE
    self.action = OPEN
}
OPENCONTAINER* (container, \fIcontentsVector\fC)
{
    unpackContentsVector(container, \fIcontentsVector\fC)
    container.open = TRUE
    container.unlocked = TRUE
    self.action = OPEN_CONTAINER
}
PAYTO* (amount)
{
    if (self == avatar) {
        bankAccountBalance += amount
    }
    self.action = RECEIVE
}
POSTURE* (newPosture)
{
    self.activity = newPosture
}
POUR* ()
{
    self.inHand.filled = FALSE
    self.action = POUR
}
PUT* (container, x, y)
{
    subjectObject = self.inHand
    changeContainers(self.inHand, container, x, y)
    self.action = PUT
}
SPEAK*
TAKE* ()
{
    self.inHand.count--
    self.action = TAKE
    if (self.inHand.count == 0) {
        destroyObject(self.inHand)
    }
}
THROW* (target, x, y, hit)
{
    self.action = THROW
    subjectObject = self.inHand
    changeContainers(self.inHand, target, x, y)
    if (hit) {
        soundEffect(SOUND_HIT)
        \fB/* *** effect of hit? *** */\fC
    }
}
WALK*
.Gr
A complex set of animation images expressing a wide range of motions and
actions.  See the document \fIAvatar Animation Specifications\fR for more
detail.
.Hb
GRAB () \(-> (success, grabbedAvatar)
{
    success = FALSE
    grabbedAvatar = FALSE
    if (emptyHanded(avatar)) {
        success = TRUE
        if (self.inHand != NULL) {
            changeContainers(self.inHand, avatar, NULL, HAND)
            # avatar \(-> GRABFROM* (self)
        } else {
            grabbedAvatar = TRUE
            self.restrainer = avatar
            # avatar \(-> GRAB* (self)
        }
    }
}
HAND () \(-> (success)
{
    if (!emptyHanded(avatar) && emptyHanded(self)) {
        success = TRUE
        changeContainers(avatar.inHand, self, NULL, HAND)
        # self \(-> GRABFROM* (avatar)
    } else {
        success = FALSE
    }
}
POSTURE (newPosture) \(-> ()
{
    if (self == avatar) {
        if (newPosture == SITTING || newPosture == LAYING || newPosture ==
                STANDING) {
            avatar.activity = newPosture
            # avatar \(-> POSTURE* (newPosture)
        }
    }
}
SPEAK (audience, \fItext\fC) \(-> ()
{
    if (audience == NULL) {
        # avatar \(-> SPEAK (\fItext\fC)
    } else {
        self \(-> SPEAK (\fItext\fC)
    }
}
WALK (x, y) \(-> (destinationX, destinationY)
{
    if (self != avatar) {
        destinationX = self.x
        destinationY = self.y
    } else {
        checkPath(region, x, y, &destinationX, &destinationY)
        if (destinationX != self.x || destinationY != self.y) {
            self.x = destinationX
            self.y = destinationY
            # self \(-> WALK* (destinationX, destinationY)
        }
    }
}
.En
.Ob
backpack
.De
Your basic backpack.
.Fu
Can carry multiple items without use of hands to hold them all.
.No
A backpack object is an object-carrier that an avatar can put on and take off
at will.  It has a large capacity, but otherwise works like an item of
clothing with pockets.
.Sy
\fRNone.
.Pr
contents                /* A list of the objects in the backpack. */
.Cl
location = BACK         /* Where on the body this is worn. */
capacity = ?            /* How many things this can carry. */
displayContents = FALSE /* Whether we should show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
wearOrUnpocket()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(\fIcontentsVector\fC)
{
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Single static frame of lone backpack, plus additional animation cels of pack
on torso of avatar in side, front and back views.
.Hb
GET
PUT
THROW
.En
.Ob
bag
.De
The sack.
.Fu
Can carry multiple items using only one hand.
.No
A bag is simply an object carrier that can be carried in the hands.
.Sy
\fRNone.
.Pr
contents        /* A list of the objects in the bag. */
open            /* Flag that bag is open. */
key             /* Key to unlock it (always null, since it has none). */
unlocked        /* Flag that it is unlocked (always TRUE). */
.Cl
capacity = ?    /* How many things this can hold. */
displayContents = FALSE /* Whether to show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
adjacentOpenCloseContainer()
.Go
goTo()
.St
cease()
.Ge
goToAndPickFromOrGet()
.Pu
goToAndDropIntoIfOpen()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(open, \fIcontentsVector\fC)
{
    self.open = open
    self.key = NULL
    self.unlocked = TRUE
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Two state image of bag: full and empty.
.Hb
CLOSECONTAINER
GET
OPENCONTAINER
PUT
THROW
.En
.Ob
ball
.De
Your standard spherical throwing toy.
.Fu
For playing games.
.No
The ball is relatively inert.  You can pick it up and throw it.  It you throw
it at an avatar who is not already holding something else, that avatar will
catch it.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw() \fB/* *** Need something special here. *** */
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of ball (no matter how you look at it, it looks the same).
.Hb
GET
PUT
THROW
.En
.Ob
bed
.De
An ordinary bed.
.Fu
Can be laid upon.
.No
The bed is a type of scenic object, usually found in building interiors.
Avatars can lay down on it.  This doesn't really change anything, it's just
for appearance.
.Sy
BED_SINGLE, BED_KING_SIZE, BED_BRASS
.Pr
orientation             /* How the bed is oriented w.r.t p.o.v.  It can be any
                           of BED_LEFT_SIDE, BED_RIGHT_SIDE, BED_FOOT or
                           BED_HEAD. */
occupants[BED_SIZE]     /* The avatars laying there.  NULL if nobody is. */
.Cl
maxOccupants = BED_SIZE = 2
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    setDownOrGetUp(LAYING)
}
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(bedStyle, orientation, occupants[BED_SIZE])
{
    self.grstyle = bedStyle
    self.orientation = orientation
    for (i=0; i<BED_SIZE; ++i) {
        self.occupants[i] = occupants[i]
    }
}
.Dy
smash()
.As
\fRNone.
.Gr
Three static images for each type of bed: side view, head view and foot view.
.Hb
\fRNone.
.En
.Ob
beeper
.De
One of those annoying little devices that disrupts movie theaters.
.Fu
Alerts you that someone is trying to call you on the phone.
.No
If a phone call arrives at your home phone when you are not there (regardless
of whether or not you have an answering machine to pick it up), the beeper
starts beeping.
.Sy
\fRNone.
.Pr
beeping         /* Flag that we are in the beeping state.  TRUE if we are. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* Press the button to stop the beeping */\fC
    if (holding(self)) {
        if (self.beeping) {
            self.beeping = FALSE
            soundEffect(SOUND_SILENCE)
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(beeping)
{
    self.beeping = beeping
}
.Dy
smash()
.As
BEEP* ()
{
    \fI/* Asynchronous action when somebody else gets beeped. */\fC
    self.beeping = TRUE
    soundEffect(SOUND_BEEPING)
}
.Gr
Single static image of beeper.  Sound of beeper beeping.
.Hb
GET
PUT
THROW
.En
.Ob
boat
.De
A nice little runabout.
.Fu
Carries avatars and their possessions across water.
.No
The boat is a vehicle that can travel on water (but, of course, not on land)
\(em rivers, ponds, seas, and so on.  It operates just like a car otherwise.
It is a simple rowboat-type boat with a small outboard motor.  It does not go
very fast nor does it carry very many people.
.Sy
\fRNone.
.Pr
contents        /* A list of the objects in the boat.  NULL if there are
                   none. */
inhabitants[BOAT_SIZE] /* The folks riding in it.  There are four slots which
                   are NULL if unoccupied.  The avatar in slot 0 gets to
                   drive. */
moving          /* A flag that the boat is in motion. */
targetX         /* Motion destination X position. */
targetY         /* Motion destination Y position. */
.Cl
capacity = ?                 /* How many things this can hold. */
displayContents = FALSE      /* Whether to show what's in it. */
maxOccupants = BOAT_SIZE = 4 /* How many people can fit in it. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
climbInOrOut()
.St
cease()
.Ge
goToAndPickFrom()
.Pu
goToAndDropInto()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(moving, targetX, targetY, inhabitants[BOAT_SIZE], \fIcontentsVector\fC)
{
    self.moving = moving
    self.targetX = targetX
    self.targetY = targetY
    for (i=0; i<BOAT_SIZE; ++i) {
        self.inhabitants[i] = inhabitants[i]
    }
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
DRIVE*
.Gr
Three static images of boat: side view, front view, back view.  Sound of boat
engine driving.
.Hb
\fRNone.
.En
.Ob
book/newspaper
.De
A readable document.
.Fu
Displays text or artwork on paper.
.No
A book's contents are kept in the host.  These are downloaded (in pieces) on
demand when the player tries to read them.  We use the full-screen text editor
routines that are used for mail and pieces of paper, but we use them in a
read-only mode that allows us to handle larger documents (since the contents
may be discarded after they have scrolled off the screen).
.Sy
DOC_BOOK, DOC_MAGAZINE, DOC_NEWSPAPER, DOC_FLYER
.Pr
position        /* Current position in the document. */
.Cl
\fRNo class properties.
.Hp
content         /* The text that makes up the content of the document. */
maximumLength   /* The size of the text. */
.Co
.Do
.nf
{
    \fI/* If holding and not already reading, start reading.  If already
       reading, read some more. */\fC
    if (holding(self)) {
        self.position = 0
        @ self!READ (self.position) \(-> (newPosition, \fItext\fC)
        self.position = newPosition
        textEditReadOnly(self, \fItext\fC)
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(documentStyle)
{
    self.grstyle = documentStyle
    self.position = 0
    self.reading = FALSE
}
.Dy
smash()
.As
\fRNone.
.Gr
A single static image of (unopened) document for each document style.  Text or
picture display of contents of document.
.Hb
GET
PUT
READ (position) \(-> (newPosition, \fItext\fC)
{
    if (holding(self) && position < self.maximumLength) {
        \fItext\fC = content[position...position+READ_LENGTH]
        newPosition = position + READ_LENGTH
    } else {
        \fItext\fC = ""
        newPosition = 0
    }
}
THROW
.En
.Ob
boomerang
.De
Your standard Australian throwing toy.
.Fu
Joke.
.No
The boomerang is rather peculiar.  It works like a ball or frisbee, except
that when you throw it it disappears off the edge of the region.  At some
random time in the future (perhaps days or weeks later) it returns to you,
wherever you are.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
returnTo        /* Avatar to return to at some random time in the future. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
.nf
{
    \fI/* Throw away. */\fC
    @ self!THROWAWAY () \(-> ()
    \fB/* *** Need to animate motion to edge of screen. *** */\fC
    destroyObject(self)
}
.In
nullInit()
.Dy
smash()
.As
THROWAWAY* ()
{
    \fB/* *** Need to animate motion to edge of screen. *** */\fC
    destroyObject(self)
}
.Gr
Two or three state image of flying boomerang.  One frame of this will suffice
for boomerang at rest.
.Hb
BoomerangReturn()
{
    \fB/* *** Make boomerang reappear in region where thrower is now located,
       and fly in and either get caught in the avatar's hands (if empty
       handed) or drop at it's feet. *** */\fC
}
GET
PUT
THROWAWAY () \(-> ()
{
    if (holding(self)) {
        self.returnTo = avatar
        # self \(-> THROWAWAY* ()
        scheduleEvent(BoomerangReturn, randomTimeInTheFuture())
        disappearObject(self)
    }
}
.En
.Ob
bottle
.De
A glass bottle.
.Fu
Holds water, other liquids.
.No
The bottle can hold liquids.  There is only one liquid substance defined right
now, water, but we may add others as the design evolves (e.g., oil, fuel,
etc.).  The bottle is either filled or empty.  There are no in-between states.
.Sy
\fRNone.
.Pr
filled          /* Flag telling whether bottle is filled or empty.  TRUE if
                   filled. */
contents        /* What is in the bottle (for now, this is always water). */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
.nf
{
    \fI/* Pour the contents of the bottle on the indicated spot.  Of course,
       you can only do this with a full bottle. */\fC
    if (goTo()) {
        if (self.filled) {
            @ self!POUR () \(-> ()
            self.filled = FALSE
            avatar.action = POUR
        }
    }
}
.In
.nf
init(filled, contents)
{
    self.filled = filled
    self.contents = contents
}
.Dy
smash()
.As
\fRNone.
.Gr
Two state image: bottle empty and bottle full.
.Hb
FILL () \(-> (success)
{
    success = (holding(self) && !self.filled && atWater())
    if (success) {
        self.filled = TRUE
        self.contents = WATER_CLASS
        # avatar \(-> FILL* ()
    }
}
GET
POUR () \(-> ()
{
    if (holding(self) && self.filled) {
        self.filled = FALSE
        self.contents = NULL
        # avatar \(-> POUR* ()
    }
}
PUT
.En
.Ob
box
.De
Your basic box.
.Fu
Can carry more than two items using only two hands.
.No
A box is simply an object carrier that can be carried in the hands.  It is
like a bag, but it has a larger capacity.  
.Sy
BOX_CARDBOARD, BOX_CRATE, BOX_TREASURE_CHEST, BOX_PICNIC_BASKET
.Pr
contents        /* A list of the objects in the box. */
open            /* Flag that box is open.  TRUE if it is. */
key             /* Key to unlock box.  Always NULL. */
unlocked        /* Flag that box is unlocked.  Always TRUE. */
.Cl
capacity = ?            /* How many things this can hold. */
displayContents = FALSE /* Whether we show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
adjacentOpenCloseContainer()
.Go
goTo()
.St
cease()
.Ge
goToAndPickFromOrGet()
.Pu
goToAndDropIntoIfOpen()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(boxStyle, open, \fIcontentsVector\fC)
{
    self.grstyle = boxStyle
    self.open = open
    self.key = NULL
    self.unlocked = TRUE
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Single static image of box for each style.
.Hb
CLOSECONTAINER
GET
OPENCONTAINER
PUT
THROW
.En
.Ob
bridge
.De
Your basic small foot or highway bridge.
.Fu
Provides a pathway across water.
.No
This is a large scenic background object.  It is different from most objects
in that the location on it that the player points to can be significant.
Topologically, it is a parallelepiped on the ground.  One pair of sides (the
``ends'') are of a fixed length (the ``width'') which will be the same for all
bridges.  The other pair of sides (the ``sides'') may vary in length depending
on the length of the bridge.  The length will be some integer multiple of of
the standard bridge section length, which is in turn based on the size of the
imagery.  It is possible to walk around on top of the bridge's surface and to
cross the ends, but it is not possible to cross the sides.
.Sy
\fRNone.
.Pr
orientation     /* Which way the the bridge is oriented w.r.t. p.o.v.
                   Possible values are BRIDGE_SIDE and BRIDGE_FRONT */
width           /* The number of standard bridge sections wide it is. */
length          /* The number of standard bridge sections long it is. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goToCursor()
.St
cease()
.Ge
noEffect()
.Pu
goToCursorAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(orientation, width, length)
{
    self.orientation = orientation
    self.width = width
    self.length = length
}
.Dy
smash()
.As
\fRNone.
.Gr
Two static images of a bridge section: side view and end view.  Which is used
depends on the value of \fCorientation\fR.  These are replicated end-to-end
(for the side view) or back-to-front (for the end view) as many times as there
are bridge sections.
.Hb
\fRNone.
.En
.Ob
building
.De
Any sort of building.
.Fu
A ``glue'' object to organize building parts into a single entity.
.No
This is a rather special sort of object.   It is not a selectable object on
the screen.  Rather, it is a mechanism for the host to tell the home system
about a whole complex of objects without having to detail them each
individually.  A building is a collection of building parts: roof, walls,
doors, windows, etc., that are displayed together.   It is used as a backdrop
to a region to show that the region behind it is a building interior of some
sort.  Buildings are not described by the host in detail.  Instead, the host
simply provides a building-type descriptor and the initialization and drawing
code for the building object provide the rest.  This means that the spectrum
of possible buildings is limited compared to the range of things possible in
general given our graphics capabilities, but it also means that the
communications overhead to describe a building is vastly reduced.
.Sy
\fRNone.
.Pr
descriptor      /* What sort of building this is.  The descriptor is three
                   or four bytes that tell how it is put together.  Various
                   bits encode such things as the roof style, the roof
                   pattern, the height (in stories) of the building, the
                   width (in standard building sections) of the building, what
                   each section is (wall, door, window, etc.), what sort of
                   doors it has, what sort of windows it has, what the wall
                   siding is and what color it is.  \fB*** The exact encoding\fC
                   \fBis TBD. ***\fC */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
\fRNone, since it is not a selectable object on the screen.
.In
.nf
init(descriptor)
{
    createBuilding(descriptor)
}
.Dy
\fRNone.
.As
\fRNone.
.Gr
The building is just the sum of its parts, produced algorithmically from the
descriptor.
.Hb
\fRNone.
.En
.Ob
bus
.De
Mass transit.
.Fu
Carries many avatars and their possessions along roads.
.No
A bus is simulated by having a region whose location changes with time.
Busses follow predetermined paths.  You board a bus by entering its region
when it is at an adjacent bus stop.  You get off by leaving its region when it
is stopped.  It costs money to ride the bus.  Bus fare is collected by a fare
box object \(em each bus region contains one.  The bulk of the player
interface to the bus itself is through the fare box object.  The bus itself is
not represented by an explicit object in the home system.
.Sy
\fRNone.
.Pr
\fRNo properties: it is not an object.
.Cl
\fRNo class properties: it is not an object.
.Hp
schedule        /* The sequence of regions the bus will visit and the times
                   that it will move between them. */
.Co
\fRNone: a bus is just a special kind of region.  It is not a selectable
object on the screen.
.In
\fRNone: it is not really an object.
.Dy
\fRNone: it is not really an object.
.As
\fRNone
.Gr
None: it is not really an object.
.Hb
\fRCode to run bus.
.En
.Ob
bush
.De
Your basic bushy plant.
.Fu
Scenic element.  Obstruction.
.No
This is a fairly inert scenic element, provided almost entirely for visual
appeal.
.Sy
BUSH_LARGE, BUSH_SMALL, BUSH_TUMBLEWEED, BUSH_SHRUB
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(bushStyle)
{
    self.grstyle = bushStyle
}
.Dy
smash()
.As
\fRNone.
.Gr
One static image for each style of bush.
.Hb
\fRNone.
.En
.Ob
car
.De
The great American automobile.
.Fu
Carries avatars and their possessions along roads.
.No
The car is a vehicle that can travel on roads.  A car can not ordinarily
travel on plain ground, unless it is one of the rare off-road vehicles.
.Sy
\fRNone.
.Pr
contents        /* A list of the objects in the car.  NULL if there are
                   none. */
inhabitants[CAR_SIZE] /* The folks riding in it.  There are four slots which
                   are NULL if unoccupied.  The avatar in slot 0 gets to
                   drive. */
moving          /* A flag that the car is in motion. */
targetX         /* Motion destination X position. */
targetY         /* Motion destination Y position. */
offRoadVehicle  /* Flag that this car can travel off the road on ordinary
                   ground. */
.Cl
capacity = ?            /* How many things this can hold. */
displayContents = FALSE /* Whether to show what's in this. */
maxOccupants = CAR_SIZE = 4
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
climbInOrOut()
.St
cease()
.Ge
goToAndPickFrom()
.Pu
goToAndDropIn()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(moving, targetX, targetY, offRoadVehicle, inhabitants[CAR_SIZE], \fIcontentsVector\fC)
{
    self.moving = moving
    self.targetX = targetX
    self.targetY = targetY
    self.offRoadVehicle = offRoadVehicle
    for (i=0; i<CAR_SIZE; ++i) {
        self.inhabitants[i] = inhabitants[i]
    }
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
DRIVE*
.Gr
Three static images of car: side view, front view, back view.  Sound of car
engine driving.
.Hb
\fRNone.
.En
.Ob
chair
.De
An ordinary chair.
.Fu
Can be sat in.
.No
The chair is a type of scenic object, usually found in building interiors.
Avatars can sit in ti.  This doesn't really change anything, it's just for
appearance.
.Sy
CHAIR_ARM, CHAIR_KITCHEN, CHAIR_STOOL, CHAIR_DESK
.Pr
orientation     /* How the chair is oriented w.r.t. p.o.v.  It can be any of
                   CHAIR_LEFT_SIDE, CHAIR_RIGHT_SIDE, CHAIR_FRONT or
                   CHAIR_BACK. */
occupants[CHAIR_SIZE]  /* Avatar that is sitting here.  NULL if nobody is. */
.Cl
maxOccupants = CHAIR_SIZE = 1
.Hp
\fRNo other properties.
.Co
.Do
sitOrGetUp()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(chairStyle, orientation, occupant)
{
    self.grstyle = chairStyle
    self.orientation = orientation
    self.occupants[0] = occupant
}
.Dy
smash()
.As
\fRNone.
.Gr
Three static images for each style of chair: side view, front view and back
view.
.Hb
\fRNone.
.En
.Ob
chest
.De
A chest of drawers.
.Fu
Can hold stuff.
.No
The chest of drawers is both a piece of furniture, for scenic purposes, and a
container.  It is a public container with two states, open and closed.  When
it is open, anyone in the region can see the contents, thus a chest of drawers
may only be opened if there are enough free object identifiers available to
identify the complete contents to all the players.
.Sy
\fRNone.
.Pr
contents        /* Contents list: a list of the objects that the chest
                   contains.  This will always be NULL if the chest is
                   closed. */
open            /* Flag telling whether the chest is open.  TRUE if open. */
key             /* Key to unlock this.  Always NULL since has no lock. */
unlocked        /* Flag that it is unlocked.  Always TRUE since no lock. */
.Cl
capacity = ?            /* How many things this can hold. */
displayContents = FALSE /* Whether we should show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
adjacentOpenCloseContainer()
.Go
goTo()
.St
cease()
.Ge
goToAndPickFromIfOpen()
.Pu
goToAndDropIntoIfOpen()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(open, \fIcontentsVector\fC)
{
    self.open = open
    self.key = NULL
    self.unlocked = FALSE
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Two state image of chest, showing it open and closed.
.Hb
CLOSECONTAINER
OPENCONTAINER
.En
.Ob
club
.De
The most basic weapon.
.Fu
Pain and injury at close range.
.No
The club is the simplest weapon.  You go up to somebody and you hit them with
it.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
strike()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of club.  Possibly multiple orientations (horizontal,
vertical, maybe diagonal) to make the animation look right.  Sound of club
striking avatar.  Sound of club striking object.
.Hb
ATTACK
BASH
GET
PUT
.En
.Ob
coke machine
.De
Soda pop vending machine.
.Fu
Decorative scenic object, joke.
.No
The coke machine mostly just sits there.  If you put a Token in it it will
take it, but it will never actually give you a coke.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
take            /* Number of tokens the machine has stolen from innocent
                   avatars. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
.nf
{
    \fI/* Try to buy a coke (nothing will happen except the payment). */\fC
    payCoinOpOrDrop(COKE_COST, SOUND_JINGLE, SOUND_CLICK_CLUNK,
        SOUND_JINK, goTo)
}
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
smallExplosion()
.As
PAY* ()
{
    spend(COKE_COST)
    soundEffect(CLICK_CLUNK)
}
.Gr
Single static image of coke machine sitting there.
.Hb
PAY () \(-> (success)
{
    success = spend(COKE_COST)
    if (success) {
        # self \(-> PAY* ()
    }
}
.En
.Ob
compass
.De
Your basic pointer to the West Pole.
.Fu
Tells absolute direction.
.No
The compass doesn't actually DO anything.  It is simply displayed in a manner
which indicates the direction that is West.
.Sy
\fRNone.
.Pr
orientation     /* The direction to the West pole, in the form of a number
                   from 0 to 3, where 0 indicates straight ahead from the
                   viewpoint, 1 indicates directly to the right, 2 indicates
                   directly towards the viewpoint, and 3 indicates directly to
                   the left. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(orientation)
{
    self.orientation = orientation
}
.Dy
smash()
.As
\fRNone.
.Gr
Four state image of compass with arrow: pointing left, pointing right,
pointing towards viewpoint, pointing away from viewpoint.
.Hb
GET
PUT
THROW
.En
.Ob
couch
.De
Your basic living room couch.
.Fu
Like chair, but can be sat in by multiple avatars.
.No
A couch works just like a chair, but it can hold two avatars.  We have to
maintain the position that each is sitting in, so we pay attention to where
the player pointed to when he gave the command to sit, and sit in the open
slot closest to that point.
.Sy
COUCH_STUFFED, COUCH_MODERN
.Pr
orientation     /* How the couch is oriented w.r.t. p.o.v.  Can be any of
                   COUCH_LEFT_SIDE, COUCH_RIGHT_SIDE, COUCH_FRONT or
                   COUCH_BACK. */
occupants[COUCH_SIZE] /* The folks sitting there.  There are two slots which
                   are NULL if unoccupied. */
.Cl
maxOccupants = COUCH_SIZE = 2
.Hp
\fRNo other properties.
.Co
.Do
sitOrGetUp()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(couchStyle, orientation, occupants[COUCH_SIZE])
{
    self.grstyle = couchStyle
    self.orientation = orientation
    for (i=0; i<COUCH_SIZE; ++i) {
        self.occupants[i] = occupants[i]
    }
}
.Dy
smash()
.As
\fRNone.
.Gr
Three static images for each style of couch: side view, front view and back
view.
.Hb
\fRNone.
.En
.Ob
countertop
.De
Store counter.
.Fu
Can support things.  Mediates transactions.
.No
The countertop is a mechanism for mediating transactions.  Objects placed on
the counter follow a slightly different protocol when being picked up by
passers by.  If you place an object on the counter, you can pick it up again.
However, if somebody else places an object on the counter, you can only pick
it up if you already placed an item of your own on the counter.  This
interlock is mediated by the host, when it decides whether a GET operation has
succeeded or not.
.Sy
\fRNone.
.Pr
contents        /* Contents list: a list of the objects that the countertop
                   contains. */
.Cl
capacity = ?            /* How many things this can hold. */
displayContents = TRUE  /* Whether we should show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropOnto()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(\fIcontentsVector\fC)
{
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Single static image of grocery store type countertop.
.Hb
\fRNone.
.En
.Ob
credit card
.De
Your basic plastic money.
.Fu
Can be used at participating businesses to pay for purchases.  Don't leave
home without it.
.No
The credit card operates exactly like a token, with two important exceptions:
First, it debits directly from your bank account (so it's actually a debit
card and not a credit card!).  Second, someone cannot take it from you and use
it like cash the way a token can.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
.nf
{
    if (target.class == AVATAR_CLASS) {
        amount = selectDenomination(bankAccountBalance)
        @ self!PAYTO (target.noid, amount) \(-> (success)
        if (success) {
            bankAccountBalance -= amount
            avatar.action = PAY
        }
    }
}
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of card.
.Hb
GET
PUT
PAYTO (targetId, amount) \(-> (success)
{
    target = \(uatargetId
    success = FALSE
    if (target.class == AVATAR_CLASS && amount >= avatar.bankAccountBalance) {
        avatar.bankAccountBalance -= amount
        target.bankAccountBalance += amount
        target \(-> PAYTO* (amount)
        success = TRUE
    }
}
.En
.Ob
crystal ball
.De
Your basic crystal ball.
.Fu
Oracle and diviner.
.No
The crystal ball functions rather like the fountain, but on a more personal
level.  It answers questions, makes predictions, and generally does all of the
things that oracles are supposed to do.  However, it is, by tradition, subtle
and not completely reliable.  Sometimes it answers your questions immediately.
Sometimes it even carries on a conversation with you.  Most of the time
though, it takes quite a while to get an answer: you have to come back several
days later.  Occasionally it says things spontaneously.  Such things are
usually important.  Anyone in the region with the crystal ball can hear what
it says.  Of course, the minds behind the ball are our own.  Somebody has to
respond, but the nature of the oracle business is such that a response need
not be timely, nor need all questions be answered.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
questions       /* List of questions asked of the crystal ball. */
answers         /* List of answers to questions waiting to be sent out.
                   \fB*** When? ***\fC */
live            /* Flag that the ball is 'live', i.e., a human is acting as
                   the voice of the crystal, rather than having it function
                   off-line. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
.nf
{
    \fI/* Ask the crystal ball a question. */\fC
    @ self!ASKORACLE (\fItext\fC) \(-> ()
}
.Re
throw()
.In
nullInit()
.Dy
mediumExplosion()
.As
ORACLESPEAK+
.Gr
Single static image of crystal ball.  Swirling effect when it is working.
.Hb
ASKORACLE
GET
PUT
THROW
.En
.Ob
die
.De
A six-sided die.
.Fu
For gambling, games.
.No
The die is a simple object, like the compass, whose only real function is to
display its own state.  Graphically, this probably won't work.  These things
really want to travel in pairs.
.Sy
\fRNone.
.Pr
state           /* A number from 1 to 6 telling the die's face value. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* If the die is in hand, roll it to get a new random state value from
       the host. */\fC
    if (holding(self)) {
        @ self!ROLL () \(-> (result)
        self.state = result
    } else if (elsewhere(self)) {
        depends()
    }
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(state)
{
    self.state = state
}
.Dy
smash()
.As
ROLL* (newState)
{
    \fI/* Asynchronous function called when somebody else rolls the die. */\fC
    self.state = newState
}
.Gr
6-state image showing the various possible die rolls.
.Hb
GET
PUT
ROLL () \(-> (result)
{
    result = random() % 6
    # self \(-> ROLL* (result)
}
THROW
.En
.Ob
display case
.De
Store display case.
.Fu
Can hold things visibly but safely, even if unattended.
.No
The display case is a transaction mediator similar to the countertop.  The
protocol that it obeys is that objects placed in it may only be picked up
again by the avatar who owns the display case.  Thus, objects can be left open
to view with impunity, even if unattended.
.Sy
\fRNone.
.Pr
contents        /* Contents list: a list of the objects that the display case
                   contains. */
owner           /* The avatar who owns this display case. */
.Cl
capacity = ?            /* How many things this can contain. */
displayContents = TRUE  /* Whether to show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropOnto()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(\fIcontentsVector\fC)
{
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Single static image of display case.
.Hb
\fRNone.
.En
.Ob
door
.De
The conventional door.
.Fu
Graphic element in buildings.  Passageway through wall.
.No
A door is like a wall section, except that it can be opened to allow passage
through it.  You can only open a door if it is unlocked or if you have the
key.  We may want to encode the open/closed state and the locked/unlocked
state into a single byte, to save room.
.Sy
DOOR_WOOD, DOOR_SCREEN, DOOR_STEEL
.Pr
open                    /* Flag indicating whether the door is open or closed.
                           TRUE if open. */
unlocked                /* Flag indicating whether or not the door is locked.
                           TRUE if unlocked. */
key                     /* Two-byte number indicating the key required for
                           this door. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
adjacentOpenClose()
.Go
goToOrPassThrough()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(doorStyle, open, unlocked, key)
{
    self.grstyle = doorStyle
    self.open = open
    self.unlocked = unlocked
    self.key = key
}
.Dy
smash()
.As
\fRNone.
.Gr
A two state image set (open door and closed door) for each door style.
.Hb
CLOSE
OPEN
.En
.Ob
dropbox
.De
A convenient roadside mail drop box.
.Fu
Interface to mail system.
.No
This is a variant on the standard mailbox.  It is like a regular mailbox,
except that it is send-only and anyone at all can use it.  Also, of course, it
\fIlooks\fR like a dropbox!
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
.nf
{
    sendMail(NO_ADDRESS_CHECK)
}
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of drop box just sitting there.
.Hb
SENDMAIL
.En
.Ob
drugs
.De
Little pills.
.Fu
Temporarily changes an avatar's properties.
.No
A drug object is represented as a pill bottle.  The bottle contains a certain
number of pills.  This number is decremented each time you take one.  When
they run out the bottle disappears.  Taking a pill causes something to happen
to the avatar.  There are a variety of possible effects, most of them bad.
\fB*** The set of possible effects needs thought ***.
.Sy
\fRNone.
.Pr
count           /* How many pills are left. */
.Cl
\fRNo class properties.
.Hp
effect          /* What the pills do.  Used as case switch for execution of
                   pills' behavior. */
.Co
.Do
.nf
{
    \fI/* Take a pill. */\fC
    if (holding(self)) {
        @ self!TAKE () \(-> ()    \fI/* Effect is conveyed asynchronously */\fC
        self.count--
        avatar.action = TAKE
        if (self.count == 0) {
            destroyObject(self)
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(count)
{
    self.count = count
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of pill bottle.
.Hb
GET
PUT
TAKE () \(-> ()
{
    if (holding(self)) {
        self.count--
        (drugEffects[self.effect])()  \fB/* *** define these *** */\fC
        (*self.effect)()
        if (self.count == 0) {
            destroyObject(self)
        }
        # avatar \(-> TAKE* ()
    }
}
THROW
.En
.Ob
escape device
.De
Your basic panic button.
.Fu
Gets you out of a jam, fast.
.No
This device is very rare and expensive.  It is a little box with a button on
it.  If you press the button, you are instantly teleported back to your turf.
Since this is such a powerful device, it is given only a limited charge.  Each
teleport uses one unit of charge.  When the charge level reaches zero, the
device disappears.  Note that the typical charge found in practice should be
1.
.Sy
\fRNone.
.Pr
charge          /* How many teleports are left in this device before it runs
                   out. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* If in hand, press button and bug out.  Actual teleport will occur
       asynchronously. */\fC
    if (holding(self)) {
        @ self!BUGOUT () \(-> (success)
        if (success) {
            soundEffect(SOUND_ZAP)
            self.charge--
            if (self.charge == 0) {
                destroyObject(self)
            }
        }
    } else if (elsewhere(self)) {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(charge)
{
    self.charge = charge
}
.Dy
smallExplosion()
.As
\fRNone.
.Gr
Single static image of device.  Sound effect when device is activated.
.Hb
BUGOUT () \(-> (success)
{
    if (holding(self)) {
        goToNewRegion(avatar, avatar.turf)
        self.charge--
        if (self.charge == 0) {
            destroyObject(self)
        }
        success = TRUE
        # avatar \(-> BUGOUT* ()
    } else {
        success = FALSE
    }
}
GET
PUT
THROW
.En
.Ob
fake gun
.De
A pistol (almost).
.Fu
Apparant death and destruction from a distance, but not really.
.No
The fake gun works like the real gun, except when you shoot with it a flag
that says "BANG!" comes out instead of actually shooting somebody.
.Sy
\fRNone.
.Pr
state           /* What state the gun is in.  Possible values are
                   FAKE_GUN_READY and FAKE_GUN_FIRED. */
safetyOn        /* Flag that the safety is on.  TRUE if it is. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* Toggle the safety. Note: the safety operation is strictly local.  It
       is only to prevent you from accidently shooting somebody, and is thus
       part of the "user interface" rather than an intrinsic part of the
       operation of the object.  If the flag is out, push it back in. */\fC
    if (holding(self)) {
        if (self.state == FAKE_GUN_FIRED) {
            self.state = FAKE_GUN_READY
            @ self!RESET () \(-> ()
        } else if (self.safetyOn) {
            soundEffect(SOUND_SAFETY_OFF)
            self.safetyOn = FALSE
        } else {
            soundEffect(SOUND_SAFETY_ON)
            self.safetyOn = TRUE
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
.nf
{
    \fI/* Try to attack somebody or something with fake gun. */\fC
    if (!self.safetyOn && self.state == FAKE_GUN_READY) {
        soundEffect(SOUND_BANG)
        avatar.action = SHOOT
        self.state = FAKE_GUN_FIRED
        @ self!FAKESHOOT () \(-> ()
    } else {
        soundEffect(SOUND_DUD)
    }
}
.In
.nf
init(state, safetyOn)
{
    self.state = state
    self.safetyOn = safetyOn
}
.Dy
smash()
.As
RESET* ()
{
    self.state = FAKE_GUN_READY
}
FAKESHOOT* ()
{
    soundEffect(SOUND_BANG)
    self.state = FAKE_GUN_FIRED
}
.Gr
Images of static gun and gun with FLAG in front and side views.  Sound of
shot.
.Hb
FAKESHOOT () \(-> ()
{
    if (holding(self) && self.state == FAKE_GUN_READY) {
        self.state = FAKE_GUN_FIRED
        # self \(-> FAKESHOOT* ()
    }
}
GET
RESET () \(-> ()
{
    if (holding(self) && self.state == FAKE_GUN_FIRED) {
        self.state = FAKE_GUN_READY
        # self \(-> RESET* ()
    }
}
PUT
.En
.Ob
fare box
.De
Mass transit fare collection box.
.Fu
Controls access to the bus system.
.No
The bus system is based on the region model.  A bus is simply a region whose
connectivity with the rest of the world changes with time.  You get on the bus
by entering the bus region, and leave the bus by exiting it, just as you would
any other region.  The bus follows a bus route, and every few minutes it moves
from one stop to another.  If you are on it when it moves, you move with it.
However, to ride the bus you must pay bus fare.  Bus fare is set by the
\fBMicroCosm\fP authorities and is uniform throughout the world.  If you do
not pay, you will be automagically transported out of the bus region when the
bus leaves and deposited in the bus stop region you entered from.
.Sy
\fRNone.
.Pr
nextStop        /* String with name of next stop on bus line */
.Cl
\fRNo class properties.
.Hp
take            /* How much money this box has collected in bus fares. */
.Co
.Do
.nf
{
    \fI/* Announce next stop */\fC
    balloonMessage(self, "Next stop %s", self.nextStop)
}
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
.nf
{
    \fI/* If item in hand is a token and you have enough money for bus fare,
       drop amount of fare in fare box, otherwise drop at foot of box. */\fC
    payCoinOpOrDrop(BUS_FARE, NULL, SOUND_DEPOSIT, SOUND_REJECT, goto)
}
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(\fInextStop\fC)
{
    self.nextStop = \fInextStop\fC
}
.Dy
smash()
.As
PAY* ()
{
    spend(BUS_FARE)
    soundEffect(SOUND_DEPOSIT)
}
DEPARTING+ (time)
{
    \fI/* Asynchronous message from host a few minutes before departure */\fC
    \fB/* *** Trigger this. *** */\fC
    balloonMessage(self, "Departing for %s in %d minutes", self.nextStop,time)
    soundEffect(SOUND_ANNOUNCE)
}
DEPARTURE+ ()
{
    \fI/* Asynchronous message from host upon departure */\fC
    \fB/* *** Trigger this. *** */\fC
    balloonMessage(self, "Departing now for %s", self.nextStop)
    soundEffect(SOUND_ANNOUNCE)
}
ARRIVAL+ (newNextStop)
{
    \fI/* Asynchronous message from host upon arrival */\fC
    \fB/* *** Trigger this. *** */\fC
    balloonMessage(self, "Arriving at %s", self.nextStop)
    soundEffect(SOUND_ANNOUNCE)
    self.nextStop = newNextStop
    balloonMessage(self, "Next stop %s", self.nextStop)
}
.Gr
Single static image of fare box.  Sound of coin dropping in box.  Sound of
rejection for insufficient fare.  Sound announcing bus departure or arrival.
.Hb
PAY () \(-> (success)
{
    if (spend(BUS_FARE)) {
        success = TRUE
        avatar.busFarePaid = TRUE
        self.take++
        # self \(-> PAY* ()
    } else {
        success = FALSE
    }
}
.En
.Ob
fence
.De
A section of an impassable, man-made barrier.
.Fu
Linear obstruction.
.No
Each fence object is a single section of fence, running vertically,
horizontally, or diagonally with respect to the viewpoint.  Fence sections are
of a standard size (say 10 feet long), so the path of a fence section can be
reckoned by the (x, y) location of one end together with a direction
indicator.  A fence blocks passage across the line that it runs on.  For
visual stylistic reasons, there are several different styles of fencing
available.
.Sy
FENCE_CYCLONE, FENCE_PICKET, FENCE_WOOD, FENCE_STONE, FENCE_BRICK
.Pr
direction       /* Which direction the fence runs from the location point, in
                   the form of a number from 0 to 8, where 0 indicates WEST, 1
                   indicates NORTHWEST, 2 indicates NORTH, and so on clockwise
                   around the compass rose.  WEST is always taken as the
                   direction directly away from the viewpoint, even if this
                   is not true West. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(fenceStyle, direction)
{
    self.grstyle = fenceStyle
    self.direction = direction
}
.Dy
smash()
.As
\fRNone.
.Gr
Three static images of a fence section: side view, end view and diagonal view,
for each style of fence.  May be composed entirely of cels, or a combination
of cels and texture-mapped trapezoids.  In the latter case, cels would be used
for the fence posts and trapezoids for the fence walls proper.  (Note: using
trapezoids would allow us to express fence sections in terms of two arbitrary
endpoints instead of a single end and a direction vector).
.Hb
\fRNone.
.En
.Ob
flag
.De
The colors.
.Fu
Scenic decoration.
.No
A flag is a decoration as well as a marker that can be carried around.
.Sy
\fRNone.
.Pr
state           /* What state the flag is in.  Possible values are
                   FLAG_WAVING, FLAG_FURLED and FLAG_EXTENDED. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends();
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(state)
{
    self.state = state
}
.Dy
smash()
.As
CHANGESTATE+ (newState)
{
    \fI/* Asynchronous message from host when the wind changes. */\fC
    \fB/* *** Trigger this. *** */\fC
    self.state = newState
}
.Gr
Animation of flag waving.  Static image of flag furled.  Static image of flag
extended.
.Hb
GET
PUT
THROW
.En
.Ob
flashlight
.De
Your basic hand torch.
.Fu
Portable light source at night.
.No
The \fBMicroCosm\fP follows a cycle of day and night.  When it is night-time,
the screen is displayed in darkened colors, which makes things hard to see.
Having a flashlight in the region makes the region appear like daytime
(provided that the light is turned on, of course), even if it is night
elsewhere.  We may wish to consider requiring batteries, but for now it just
works forever.
.Sy
\fRNone.
.Pr
on              /* Flag telling whether the light is on or off.  TRUE if it is
                   on. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* If holding, turn on or off.  Otherwise, depends. */\fC
    if (toggleSwitch(holding(self))) {
        if (self.on) {
            lightLevel++
        } else {
            lightLevel--
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(on)
{
    self.on = on
}
.Dy
smash()
.As
OFFLIGHT*
ONLIGHT*
.Gr
Static image of flashlight in two orientations: horizontal and vertical.
Which orientation to use depends on how it is being held (\fB*** unsolved
problem***\fP).
.Hb
GET
OFF
ON
PUT
THROW
.En
.Ob
floor lamp
.De
A household floor lamp.
.Fu
Provides light at night.
.No
The \fBMicroCosm\fP follows a cycle of day and night.  When it is night-time,
the screen is displayed in darkened colors, which makes things hard to see.
Having a floor lamp in the region makes the region appear like daytime
(provided that the lamp is turned on, of course), even if it is night
elsewhere.  The floor lamp is a decorative furniture object also.
.Sy
\fRNone.
.Pr
on              /* Flag telling whether or not the lamp is turned on.  TRUE if
                   it is on. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* Flip the light switch. */\fC
    if (toggleSwitch(!elsewhere(self))) {
        if (self.on) {
            lightLevel++
        } else {
            lightLevel--
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(on)
{
    self.on = on
}
.Dy
smash()
.As
OFFLIGHT*
ONLIGHT*
.Gr
Single static image of floor lamp.
.Hb
OFF
ON
.En
.Ob
fortune machine
.De
A vending machine that tells your fortune.
.Fu
Humor.
.No
The fortune machine is a little like the oracle, but less profound.  You give
it a token and it tells you a fortune.  The fortunes are little proverbs,
sayings, predictions and pieces of advice in the tradition of fortune cookie
programs everywhere.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
count           /* How many fortunes this machine has dispensed. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
.nf
{
    \fI/* Spend the price and speak the saying that comes out. */\fC
    if (payCoinOpOrDrop(FORTUNE_COST, SOUND_JINGLE,
            SOUND_CLICK_CLUNK, SOUND_JINK, goTo)) {
        balloonMessage(self, "%s", \fItext\fC)
    }
}
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
smash()
.As
SPEAKFORTUNE* (\fItext\fC)
{
    \fI/* Asynchronous message from host when somebody else puts coin in
       machine. */\fC
    balloonMessage(self, "%s", \fItext\fC)
}
.Gr
Single static image of fortune machine.
.Hb
PAY () \(-> (success, \fItext\fC)
{
    if (spend(FORTUNE_COST)) {
        success = TRUE
        \fItext\fC = fortunes[random() % FORTUNE_COUNT]
        # self \(-> SPEAKFORTUNE* (\fItext\fC)
    } else {
        success = FALSE
        \fItext\fC = ""
    }
}
.En
.Ob
fountain
.De
Generic looking tacky town square fountain.
.Fu
Scenic element.  Water source.  Oracle.
.No
The fountain is a major scenic element, but its most dramatic function is as
oracle.  The oracle answers questions, makes predictions, and generally does
all of the things that oracles are supposed to do.  However, it is, by
tradition, subtle and not completely reliable.  Sometimes it answers your
questions immediately.  Sometimes it even carries on a conversation with you.
Most of the time though, it takes quite a while to get an answer: you have to
come back several days later.  Occasionally it says things spontaneously.
Such things are usually important.  Anyone in the region with the oracle can
hear what it says.  Of course, the minds behind the oracle are our own.
Somebody has to respond, but the nature of the oracle business is such that a
response need not be timely, nor need all questions be answered.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
questions       /* List of questions asked of the oracle. */
answers         /* List of answers to questions waiting to be sent out.
                   \fB*** When? ***\fC */
live            /* Flag that the oracle is 'live', i.e., a human is acting as
                   the voice of the oracle, rather than having it function
                   off-line. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndFill()
.Pu
goToAndDropAt()
.Ta
.nf
{
    \fI/* Ask the oracle a question. */\fC
    @ self!ASKORACLE (\fItext\fC) \(-> ()
}
.Re
/* This can't happen */
.In
nullInit()
.Dy
nullDestroy()
.As
ORACLESPEAK+
.Gr
Single static image of fountain.  Possible animation of water spurting up.
Possible process sound effect of water spurting.
.Hb
ASKORACLE
.En
.Ob
frisbee
.De
Your standard disk throwing toy.
.Fu
For playing games.
.No
The frisbee is relatively inert.  You can pick it up and throw it.  If you
throw it at an avatar who is not already holding something else, that avatar
will catch it.  The frisbee operates just like the ball, except that it has a
different sort of flight path.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw() \fB/* *** Need something special here. *** */
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Two-state (orientation dependent) image of frisbee: flat on and edge on.
.Hb
GET
PUT
THROW
.En
.Ob
garbage can
.De
Conventional garbage can or wastebasket.
.Fu
Makes things disappear.
.No
The garbage can is a means for getting rid of things.  It operates like any
other container, except that upon command it will cause to disappear anything
inside it.
.Sy
GARBAGE_CAN, GARBAGE_WASTEBASKET
.Pr
contents        /* Contents list: a list of the objects that the garbage can
                   contains.  */
.Cl
capacity = ?            /* How many things this holds. */
displayContents = FALSE /* Whether we should show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* Empty the trash. */\fC
    if (!elsewhere(self)) {
        @ self!FLUSH () \(-> ()
        purgeContents(self)
        soundEffect(SOUND_FLUSH)
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndPickFrom()
.Pu
goToAndDropInto()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(garbageCanStyle, \fIcontentsVector\fC)
{
    self.grstyle = garbageCanStyle
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
FLUSH* ()
{
    purgeContents(self)
    soundEffect(SOUND_FLUSH)
}
.Gr
A single static image of the garbage can for each style.  Sound effect of
garbage being flushed.
.Hb
FLUSH () \(-> ()
{
    if (!elsewhere(self)) {
        destroyContents(self)
        # self \(-> FLUSH* ()
    }
}
.En
.Ob
gate
.De
A gate in a fence or wall.
.Fu
Provides a way to put a passageway through a fence.
.No
A gate is like a fence section, except that it can be opened to allow passage
through it.  You can only open a gate if it is unlocked or if you have the
key.  We may want to encode the open/closed state and the locked/unlocked
state into a single byte, so that we can use a simple table to determine what
to do when opening and closing, rather than having complicated if-then-else
code.
.Sy
FENCE_CYCLONE, FENCE_PICKET, FENCE_WOOD, FENCE_STONE, FENCE_BRICK
.Pr
open                    /* Flag indicating whether the gate is open or closed.
                           TRUE if open. */
unlocked                /* Flag indicating whether or not the gate is locked.
                           TRUE if unlocked. */
key                     /* Two-byte number indicating the key required for
                           this gate. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
adjacentOpenClose()
.Go
goToOrPassThrough()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(gateStyle, open, unlocked, key)
{
    self.grstyle = gateStyle
    self.open = open
    self.unlocked = unlocked
    self.key = key
}
.Dy
smash()
.As
\fRNone.
.Gr
A two state image set (open gate and closed gate) for each fence style.
.Hb
CLOSE
OPEN
.En
.Ob
gemstone
.De
Like a rock, only worth more.
.Fu
Valuable.  May contain magic.
.No
Some objects in the \fBMicroCosm\fP are magical.  A magical object is one that
does something special and powerful in addition to whatever other things the
object would do intrinsically.  The magical function may vary.  \fB*** The set
of magical functions needs thought. ***\fP
.Sy
GEM_RUBY, GEM_DIAMOND, etc.
.Pr
magic           /* Flag that this is a magical gemstone.  (Perhaps we should
                   keep this a secret?). */
.Cl
\fRNo class properties.
.Hp
magicType       /* What sort of magic this gemstone contains.  Used as case
                   switch for execution of magical behavior. */
.Co
.Do
doMagicIfMagic()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(gemstoneStyle, magic)
{
    self.grstyle = gemstoneStyle
    self.magic = magic
}
.Dy
smallExplosionIfMagic()
.As
\fRFunctions appropriate for home-resident part of magical behavior.
.Gr
Single static image of gemstone.  Stylistic variations possible due to stone
style.
.Hb
GET
MAGIC
PUT
THROW
.En
.Ob
generic flat animal
.De
Anonymous mammal that was run over by a truck sometime earlier.
.Fu
Joke.
.No
This is a completely inert scenic object.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of animal laying in the road.
.Hb
GET
PUT
THROW
.En
.Ob
grenade
.De
A little bomb that goes boom.
.Fu
Death and mayhem in quantity.
.No
A grenade has a pin.  It is harmless unless the pin is pulled.  If the pin is
pulled, then it will explode the next time it leaves the avatar's hand,
blowing up everything at or near the destination location.  Also, once the pin
is pulled it may not be reinserted.
.Sy
\fRNone.
.Pr
pinPulled      /* Flag that the pin has been pulled.  TRUE if it has been. */
.Cl
\fRNo class properties.
.Hp
timer           /* Delay timer after pin is pulled. */
.Co
.Do
.nf
{
    \fI/* Pull the pin. */\fC
    if (holding(self) && !self.pinPulled) {
        @ self!PULLPIN () \(-> (success)
        if (success) {
            self.pinPulled = TRUE
            soundEffect(SOUND_PINPULL)
            avatar.action = PULL_PIN
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw() \fI/* Damage effects occur asynchronously. */\fC
.In
.nf
init(pinPulled)
{
    self.pinPulled = pinPulled
}
.Dy
mediumExplosion()
.As
EXPLODE+ ()
{
    \fI/* Asynchronous message when grenade blows up. */\fC
    explosionAt(self.x, self.y, SMALL_EXPLOSION)
    destroyObject(self)
    \fB/* *** Damage? *** */\fC
}
.Gr
Two state image of grenade: static state and pin pulled.  Animation of
explosion.  Sound of pin being pulled.  Sound of explosion.
.Hb
GET
PULLPIN () \(-> (success)
{
    if (holding(self) && !self.pinPulled) {
        self.pinpulled = TRUE
        success = TRUE
        scheduleEvent(GrenadeExplosion, GRENADE_FUSE_DELAY)
    } else {
        success = FALSE
    }
}
PUT
THROW
GrenadeExplosion()
{
    # self \(-> EXPLODE+ ()
    self \(-> EXPLODE+ ()
    destroyObject(self)
    \fB/* *** Damage? *** */\fC
}
.En
.Ob
ground
.De
The basic background below the horizon.
.Fu
Can be walked on.  Can be pointed at, returning a location.
.No
This is not really an object, but is treated as one to make the player
interface clean.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goToCursor()
.St
cease()
.Ge
noEffect()
.Pu
goToCursorAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
nullDestroy()
.As
\fRNone.
.Gr
Absolute blank, single color background from bottom of graphics window up to
the horizon line (i.e., a filled rectangle).  Drawn by background rendering
initialization routines.
.Hb
\fRNone.
.En
.Ob
gun
.De
A pistol.
.Fu
Death and destruction from a distance.
.No
A gun works pretty much as you would expect.  It does have a safety switch,
which must unset before the gun will shoot.  You shoot by pointing at the
target and selecting \fBdo\fP.  We should decide if requiring ammunition would
be a good idea.
.Sy
\fRNone.
.Pr
safetyOn        /* Flag that the safety is on.  TRUE if it is. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* Toggle the safety. Note: the safety operation is strictly local.  It
       is only to prevent you from accidently shooting somebody, and is thus
       part of the "user interface" rather than an intrinsic part of the
       operation of the object. */\fC
    if (holding(self)) {
        if (self.safetyOn) {
            soundEffect(SOUND_SAFETY_OFF)
            self.safetyOn = FALSE
        } else {
            soundEffect(SOUND_SAFETY_ON)
            self.safetyOn = TRUE
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
shoot()
.In
.nf
init(safetyOn)
{
    self.safetyOn = safetyOn
}
.Dy
mediumExplosion()
.As
\fRNone.
.Gr
Images of static gun and gun shooting in front and side views.  Sound of shot.
Sound of shot striking avatar.  Sound of shot striking object.
.Hb
ATTACK
BASH
GET
PUT
.En
.Ob
hand of god
.De
The finger of doom.
.Fu
An indispensible system management tool.
.No
The hand of god is a giant animated hand that comes down off the top of the
screen and fires a lightning bolt off its finger at a target, resulting a
large explosion that leaves a small pile of smoking cinders in its wake.
.Sy
\fRNone.
.Pr
state           /* What state the hand is in.  Possible values are
                   GOD_DORMANT, GOD_FIRING and GOD_CINDERS. */
target          /* Who or what is to be blasted. */
.Cl
\fRNo class properties.
.Hp
\fRNo additional properties.
.Co
\fRNone: it is never selectable on the screen.
.In
.nf
init(state, target)
{
    self.state = state
    self.target = target
}
.Dy
nullDestroy()
.As
BLAST* (target)
{
    self.target = target
    self.state = GOD_FIRING
    destroyObject(target)
}
.Gr
Animation of hand, lightning bolt and cinder cone, as described above.
.Hb
\fRTriggered on command by system operator.
.En
.Ob
hat
.De
Your basic hat.
.Fu
Decorative.  Helps distinguish one avatar from another.
.No
A hat is simply a piece of clothing that serves to personalize an avatar.  It
is represented by a cel that simply follows the avatar's head.
.Sy
HAT_BASEBALL, HAT_COWBOY, HAT_PANAMA, HAT_FEDORA, HAT_BERET, HAT_CRASH_HELMET,
HAT_COMBAT_HELMET, HAT_SKI_MASK, etc.
.Pr
\fRNo properties.
.Cl
location = HEAD         /* Where this is worn. */
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
wear()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(hatStyle)
{
    self.grstyle = hatStyle
}
.Dy
smash()
.As
\fRNone.
.Gr
Cel of hat for each style of hat in side, front and back views.
.Hb
GET
PUT
THROW
.En
.Ob
house cat
.De
A lazy cat that lays around the house.
.Fu
Scenic element.  Puzzle with no solution.
.No
The housecat just lays there and sleeps.  Every time to reenter the room its
in a different spot.  You can't pick it up or move it.
.Sy
\fRNone.
.Pr
\fRNo properties
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
A static image of a sleeping cat
.Hb
\fB/* *** Need to move the cat around when the region it is in is empty.
Also, how does the cat get there in the first place?  (Maybe it just shows up
and adopts you?) *** */\fC
.En
.Ob
hot tub
.De
A touch of Marin.
.Fu
A place to hang out.
.No
The hot tub is a silly in-joke.  In spite of its esoteric appearance, it
actually operates more or less like a couch.  The only difference is that it
has a front part and a back part so that the avatars can be sandwiched in
between and thus look like they are in the water.  It's also a water source.
.Sy
\fRNone.
.Pr
occupants[TUB_SIZE] /* The folks sitting in it.  There are four slots which
                   are NULL if unoccupied. */
.Cl
maxOccupants = TUB_SIZE = 4
.Hp
\fRNo other properties.
.Co
.Do
sitOrGetUp()
.Go
goTo()
.St
cease()
.Ge
goToAndFill()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(occupants[TUB_SIZE])
{
    for (i=0; i<TUB_SIZE; ++i) {
        self.occupants[i] = occupants[i]
    }
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of hot tub in two parts, front and back.  We paint the
back, then the avatars, then the front.
.Hb
\fRNone.
.En
.Ob
instant object pill
.De
A little pill, until you use it.
.Fu
Add water, it turns into some object.
.No
A instant object pill looks like an ordinary pill, until you pour water on it,
at which point it transforms into some other sort of object.  A instant object
pill can, conceivably, turn into anything.
.Sy
\fRNone.
.Pr
instantWhat     /* Class of object that this turns into. */
.Cl
\fRNo class properties.
.Hp
initialization  /* Init vector. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(instantWhat)
{
    self.instantWhat = instantWhat
}
.Dy
smash()
.As
TRANSFORM* (\fIinitializationVector\fC)
{
    \fI/* Asynchronous action when somebody pours water on the pill. */\fC
    \fB/* *** Need to trigger this with pour. *** */\fC
    newObject = createObject(self.instantWhat, self.container, self.x, self.y)
    soundEffect(SOUND_TRANSFORMATION)
    destroyObject(self)
    newObject.init(\fIinitializationVector\fC)
}
.Gr
Single static image of pill.  Sound of metamorphosis.
.Hb
GET
PUT
THROW
.En
.Ob
jacket
.De
Your basic jacket.
.Fu
Decorative.  Helps distinguish one avatar from another.
.No
A jacket is a clothing object whose primary purpose is to personalize avatars.
It also has pockets, which are useful for holding things without resorting to
hands.  There is only one sort of jacket, but it comes in a variety of
patterns.
.Sy
\fRNone.
.Pr
pattern         /* The pattern the jacket cels should be painted with. */
contents        /* A list of the objects in the jacket's pockets.  NULL if
                   the pockets are empty. */
.Cl
location = TORSO        /* Where this is worn. */
capacity = ?            /* How many things this holds. */
displayContents = FALSE /* Whether to show what's in this. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
wearOrUnpocket()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(pattern, \fIcontentsVector\fC)
{
    self.pattern = pattern
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Single static image of jacket in heap, plus avatar animation cels showing
jacket on torso in front, side and back views.
.Hb
GET
PUT
THROW
.En
.Ob
jukebox
.De
The all-American Rockola.
.Fu
Plays music.
.No
The jukebox is a coin operated music machine.  It works more or less like a
real jukebox.  You drop a Token into it, press ``B17'' or something like that,
and it starts playing music.
.Sy
\fRNone.
.Pr
playsToGo       /* How many plays the jukebox has left before the money runs
                   out. */
playing         /* Flag that jukebox is currently playing music (the jukebox
                   lights up when it is playing. */
.Cl
\fRNo class properties.
.Hp
music           /* The selection of music in the jukebox. */
musicCount      /* How many items are in the music selection list. */
catalogPtr      /* Current position flipping through the catalog. */
playlist        /* Selections queued for playing. */
playPointer     /* Where we are in the current selection. */
.Co
.Do
.nf
{
    \fI/* Flip through music catalog. */\fC
    if (goTo()) {
        @ self!CATALOG () \(-> (letter, number, \fItext\fC)
        balloonMessage(self, "%c%d: %s", letter, number, \fItext\fC)
    }
}
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
.nf
{
    \fI/* If the avatar has a token in hand, activate the jukebox.  Otherwise,
       drop whatever is in hand next to the jukebox. */\fC
    if (payCoinOpOrDrop(JUKEBOX_COST, SOUND_JINGLE,
            SOUND_CLICK_CLUNK, SOUND_JINK, goTo)) {
        self.playsToGo++
    }
}
.Ta
.nf
{
    \fI/* Take the text string as the jukebox selection desired. */\fC
    if (self.playsToGo > 0) {
        @ self!SELECT (\fItext\fC) \(-> (success)
        if (success) {
            self.playsToGo--
        }
    } else {
        broadcast()
    }
}
.Re
/* This can't happen */
.In
.nf
init(playsToGo, playing)
{
    self.playsToGo = playsToGo
    self.playing = playing
}
.Dy
smash()
.As
PLAY+ (\fIscore\fC)
{
    \fI/* Asynchronous function when the host tells the box to play some
       tunes.  The host actually sends the notes to play and our music driver
       plays them. */\fC
    \fB/* *** Trigger this. *** */\fC
    self.playing = TRUE
    playMusic(\fIscore\fC)
}
.Gr
Two state image of jukebox from the front: playing and not playing.  When
playing the jukebox is all lit up.  When it's not it's not.
.Hb
CATALOG () \(-> (letter, number, \fItext\fC)
{
    if (!elsewhere(self)) {
        letter = music[catalogPtr]->letter
        number = music[catalogPtr]->number
        \fItext\fC = music[catalogPtr]->\fItext\fC
        catalogPtr = (catalogPtr + 1) % musicCount
    }
}
PAY () \(-> (success)
{
    if (spend(JUKEBOX_COST)) {
        playsToGo++
        success = TRUE
    } else {
        success = FALSE
    }
}
SELECT (\fItext\fC) \(-> (success)
{
    selection = lookupSelection(music, musicCount, \fItext\fC)
    if (selection != NULL) {
        playsToGo--
        newPlay = alloc(PLAY_ENTRY)
        newPlay->play = selection
        newPlay->nextPlay = playList
        playList = newPlay
        if (!playing) {
            playing = TRUE
            playPointer = playList
        }
        success = TRUE
    } else {
        success = FALSE
    }
}
.En
.Ob
key
.De
A key for our unpickable locks.
.Fu
Opens locked doors, containers.
.No
Each key object has a key number, as does each object with a lock (doors,
containers, and so on).  You can open locks with a key whose number matches
that of the lock.  It is possible for there to be more than one key object in
the world with given key number, so that a lock can have multiple keys.
To use a key, all you have to do is have it in your hand when you try to open
the locked thing.
.Sy
\fRNone.
.Pr
keyNumber       /* What locks this key fits. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(keyNumber)
{
    self.keyNumber = keyNumber
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of key.
.Hb
GET
PUT
THROW
.En
.Ob
knick knack
.De
Your basic gewgaw.
.Fu
Scenic element.  Possibly magical.
.No
Knick knacks are usually inert scenic objects, intended only to clutter up a
scene for purposes of visual variety.  Occasionally, a knick-knack will be
magical.  The set of possible gewgaws is nearly infinite.  We will pick a
reasonable sample of two to four different styles.
.Sy
GEWGAW_TROPHY, GEWGAW_STATUETTE, GEWGAW_PAPERWEIGHT, GEWGAW_CANDELABRA,
GEWGAW_VASE
.Pr
magic           /* Flag that this is a magical knick-knack.  (Should we keep
                   this secret?) */
.Cl
\fRNo class properties.
.Hp
magicType       /* What sort of magic this gew-gaw contains.  Used as case
                   switch for execution of magical behavior. */
.Co
.Do
doMagicIfMagic()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(knickKnackStyle, magic)
{
    self.grstyle = knickKnackStyle
    self.magic = magic
}
.Dy
smallExplosionIfMagic()
.As
\fRNone.
.Gr
A static image of the knick-knack for each style that there is.
.Hb
GET
MAGIC
PUT
THROW
.En
.Ob
knife
.De
Sharp pointy thing.
.Fu
Death and injury at close range.
.No
The knife works like a club: you go up to somebody and attack them with it.
The difference is that the knife does more damage to avatars and less damage
to property.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
strike()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of knife.  Possibly multiple orientations (horizontal,
vertical, maybe diagonal) to make the animation look right.  Sound of knife
striking avatar.  Sound of knife striking object.
.Hb
ATTACK
BASH
GET
PUT
.En
.Ob
magic lamp
.De
Just like Aladdin had...
.Fu
Rub it and a genie appears to grant a wish.
.No
The magic lamp object represents both the magic lamp and the genie.  You rub
on the lamp and the genie appears.  The first thing you say is interpreted as
your wish and then the genie disappears.  The genie operates like the oracle:
it takes down your request; at some point one of our system people reviews the
request and does something in response.  It may take a while for your wish to
be answered, and even then the answer may not be what you want or expect.  The
genie only grants one wish per person.  Once the genie has noted your wish he
disappears, and the lamp disappears with him.  If you need to make another
wish you must find another lamp (and another genie).
.Sy
\fRNone.
.Pr
lampState       /* What state of the wish granting process the lamp is in.
                   Possible states are MAGIC_LAMP_WAITING and
                   MAGIC_LAMP_GENIE. */
wisher          /* Who is making the wish (only the person who rubbed the lamp
                   may make the wish.) */
.Cl
\fRNo class properties.
.Hp
wishes          /* Queue of unprocessed wishes (what the wishes were and who
                   wished for them.) */
timeout         /* Delay process to kill genie when player waits too long. */
.Co
.Do
.nf
{
    \fI/* If you are the one holding the lamp, rub it and make the genie
       appear.  Otherwise, depends. */\fC
    if (holding(self)) {
        if (self.lampState == MAGIC_LAMP_WAITING) {
            @ self!RUB () \(-> (success)
            if (success) {
                self.lampState = MAGIC_LAMP_GENIE
                self.wisher = avatar
                soundEffect(SOUND_POOF)
                balloonMessage(self, "Your wish is my command.")
            }
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
.nf
{
    \fI/* Make a wish... */\fC
    if (self.lampState == MAGIC_LAMP_GENIE && self.wisher == avatar) {
        @ self!WISH (\fItext\fC) \(-> ()
        balloonMessage(self, "I'll see what I can do.")
        soundEffect(SOUND_WHOOSH)
        destroyObject(self)
    } else {
        broadcast()
    }
}
.Re
throw()
.In
.nf
init(lampState, wisher)
{
    self.lampState = lampState
    self.wisher = wisher
}
.Dy
smash()
.As
RUB* ()
{
    self.lampState = MAGIC_LAMP_GENIE
    self.wisher = self.container
    soundEffect(SOUND_POOF)
}
WISH* ()
{
    soundEffect(SOUND_WHOOSH)
    destroyObject(self)
}
GIVEUP+ ()
{
    \fI/* Asynchronous action when player has gone too long without wishing.
       (The genie won't wait forever!) */\fC
    balloonMessage(self, "Time's up.  You lose.")
    soundEffect(SOUND_WHOOSH)
    destroyObject(self)
}
.Gr
Image of lamp sitting there, and lamp with genie hovering over it.  Animation
of genie appearing and disappearing.  Possible animation of genie hovering.
Sound of genie appearing.  Sound of genie vanishing.
.Hb
GET
PUT
RUB () \(-> (success)
{
    if (holding(self) && self.lampState == MAGIC_LAMP_WAITING) {
        self.lampState = MAGIC_LAMP_GENIE
        self.wisher = avatar
        success = TRUE
        self.timeout = scheduleEvent(GenieGivesUp, GENIE_TIMEOUT_DELAY)
        # self \(-> RUB* ()
    } else {
        success = FALSE
    }
}
THROW
WISH (\fItext\fC) \(-> ()
{
    if (self.wisher == avatar) {
        cancelEvent(self.timeout)
        newWish = alloc(WISH_ENTRY)
        newWish->wish = \fItext\fC
        newWish->previousWish = self.wishes
        newWish->wisher = self.wisher
        self.wishes = newWish
        # self \(-> WISH* ()
}
GenieGivesUp()
{
    # self \(-> GIVEUP+ ()
    self \(-> GIVEUP+ ()
    destroyObject(self)
}
.En
.Ob
magic staff
.De
A stick about as tall as an avatar.
.Fu
Generic magic talisman.
.No
Staves are usually magical.  An staff will do something special and powerful.
The magical function may vary.  \fB*** The set of magical functions needs
thought. ***\fP  Staves are relatively rare and contain unusually powerful
forms of magic.  The general function of an staff will be to transform
something or to perform some other specific action.
.Sy
STAFF_PLAIN, STAFF_JEWELED
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
magicType       /* What sort of magic this staff contains.  Used as case
                   switch for execution of magical behavior. */
.Co
.Do
doMagic()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
strike()
.In
.nf
init(staffStyle)
{
    self.grstyle = staffStyle
}
.Dy
smallExplosion()
.As
\fRNone.
.Gr
Single static image of staff for each staff style.   Possible alternate
orientations (horizontal, vertical, diagonal) to make the animation nice.
.Hb
ATTACK
BASH
GET
MAGIC
PUT
.En
.Ob
magic wand
.De
Just like your fairy godmother has.
.Fu
Generic magic talisman.
.No
Wands are usually magical.  A wand will do something special but it not as
powerful as a staff.  The magical function may vary.  \fB*** The set of
magical functions needs thought. ***\fP  Wands are relatively common as
magical objects go (which is not very common at all) and usually contain
fairly ordinary forms of magic.  The general function of a wand will be to
transform something or to perform some other specific action.
.Sy
WAND_PLAIN, WAND_STARRED
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
magicType       /* What sort of magic this wand contains.  Used as case
                   switch for execution of magical behavior. */
.Co
.Do
doMagic()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
strike()
.In
.nf
init(wandStyle)
{
    self.grstyle = wandStyle
}
.Dy
smallExplosion()
.As
\fRNone.
.Gr
Single static image of wand for each wand style.  Possible alternate
orientations (horizontal, vertical, diagonal) to make the animation nice.
.Hb
ATTACK
BASH
GET
MAGIC
PUT
.En
.Ob
mailbox
.De
A conventional household roadside mailbox.
.Fu
Interface to mail system.
.No
The mailbox lets us send and receive mail.  A little red flag tells us that
mail has arrived!
.Sy
\fRNone.
.Pr
mailArrived     /* Flag that there is mail waiting */
address         /* Mail address associated with this mailbox */
.Cl
\fRNo class properties.
.Hp
letters         /* Queue of unread letters. */
owner           /* The avatar whose mailbox this is. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* If there is mail for you, it is taken out of the mailbox you are
       popped into the sheet-of-paper handler to read it.  Note that only a
       mailbox's owner can take mail out of it. */\fC
    if (goTo()) {
        if (self.mailArrived && emptyHanded(avatar) && address == avatar.address) {
            @ self!READMAIL () \(-> (moreMail, \fItext\fC)
            self.mailArrived = moreMail
            message = createPaperObject(\fItext\fC)
            textEdit(message)
        }
    }
}
.Pu
.nf
{
    sendMail(ADDRESS_CHECK)
}
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(mailArrived, address)
{
    self.mailArrived = mailArrived
    self.address = address
}
.Dy
smash()
.As
MAILARRIVED* ()
{
    \fI/* Asynchronous message from host when new mail arrives */\fC
    \fB/* *** Trigger this. *** */\fC
    self.mailArrived = TRUE
}
.Gr
Two state image of mailbox, with little red flag up or down depending on
whether or not there is mail waiting to be read.
.Hb
READMAIL () \(-> (moreMail, \fItext\fC)
{
    if (self.mailArrived && emptyHanded(avatar) && owner == avatar) {
        \fItext\fC = letters->\fItext\fC
        deadLetter = letters
        letters = letters->nextLetter
        garbageCollect(deadLetter)
        mailArrived = (letters != NULL)
        moreMail = mailArrived
    } else {
        moreMail = FALSE
        \fItext\fC = ""
    }
}
SENDMAIL
.En
.Ob
matchbook
.De
An empty book of matches
.Fu
Has an ad that you can read.
.No
The matchbook is actually an information carrying device.  There are never any
matches.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
text
.Co
.Do
.nf
{
    \fI/* If holding the matchbook, read it.  Otherwise depends. */\fC
    if (holding(self)) {
        @ self!README () \(-> (\fItext\fC)
        balloonMessage(self, "%s", \fItext\fC)
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of matchbook.
.Hb
GET
PUT
README () \(-> (\fItext\fC)
{
    if (holding(self)) {
        \fItext\fC = self.text
    } else {
        \fItext\fC = ""
    }
}
THROW
.En
.Ob
microphone
.De
A reporter's microphone.
.Fu
Prop.
.No
This object doesn't actually do anything (yet).
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of microphone.
.Hb
GET
PUT
THROW
.En
.Ob
motorcycle
.De
Your basic motorcyle.
.Fu
Carries one avatar around.
.No
The motorcycle is a vehicle that can travel on roads and sidewalks.  It can
only carry one avatar and it can't carry any other objects except what is
already on the avatar's person.
.Sy
\fRNone.
.Pr
inhabitants[CYCLE_SIZE] /* The avatar riding in it.  This is NULL if there is
                   no rider. */
moving          /* A flag that the motorcycle is in motion. */
targetX         /* Motion destination X position. */
targetY         /* Motion destination Y position. */
.Cl
maxOccupants = CYCLE_SIZE = 1
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
climbInOrOut()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(moving, targetX, targetY, inhabitant)
{
    self.moving = moving
    self.targetX = targetX
    self.targetY = targetY
    self.inhabitants[0] = inhabitant
}
.Dy
smash()
.As
DRIVE*
.Gr
Three static images of motorcyle: side view, front view and back view.  Sound
of engine.
.Hb
\fRNone.
.En
.Ob
movie/television camera
.De
The basic tool of journalism and drama.
.Fu
Provides a way to record ongoing events.
.No
When the camera is on, the host records everything that happens in the region
so that it can be played back later.
.Sy
\fRNone.
.Pr
on              /* Flag that the camera is on. TRUE if it is. */
.Cl
\fRNo class properties.
.Hp
film            /* The record made by this camera. */
.Co
.Do
.nf
{
    if (!toggleSwitch(!elsewhere(self))) {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(on)
{
    self.on = on
}
.Dy
smash()
.As
OFF*
ON*
.Gr
Two-state image of camera with indicator light on and off.  Also, humming
sound when it is on.
.Hb
GET
OFF
ON
PUT
THROW
\fB/* *** Need some way to record passing events, and some way to play them back again. *** */\fC
.En
.Ob
pants
.De
A pair of pants.
.Fu
Decorative.  Helps distinguish one avatar from another.
.No
Pants are an item of clothing whose primary purpose is to personalize avatars.
They also have pockets.  There are a few different styles of pants which are
available in a variety of patterns.
.Sy
PANTS_LONG, PANTS_SHORT
.Pr
pattern         /* What pattern the pants cel should be painted with. */
contents        /* A list of the objects in the pants pockets. */
.Cl
location = LEGS         /* Where this is worn. */
capacity = ?            /* How many things this can hold. */
displayContents = FALSE /* Whether to show what's in this. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
wearOrUnpocket()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(pantsStyle, pattern, \fIcontentsVector\fC)
{
    self.grstyle = pantsStyle
    self.pattern = pattern
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
For each style, we need a single static image of pants in heap, plus avatar
animation cels showing pants on legs in front, side and back views.
.Hb
GET
PUT
THROW
.En
.Ob
paper
.De
A piece of paper.
.Fu
Can be written upon and then retrieved.
.No
Any piece of paper whose text begins ``to \fIname\fR'' can be sent as a mail
message.
.Sy
\fRNone.
.Pr
text            /* The text that is on the piece of paper. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    if (holding(self)) {
        textEdit(self)
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
.nf
{
    if (adjacent(self) && holdingClass(PENCIL_CLASS)) {
        writeTo(self, \fItext\fC)  \fB/* *** shakey *** */\fC
    } else {
        broadcast()
    }
}
.Re
throw()
.In
.nf
init(\fItext\fC)
{
    self.text = \fItext\fC
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of piece of paper.  Text display of paper contents.
.Hb
GET
PUT
THROW
.En
.Ob
parking meter
.De
Coin operated parking meter.
.Fu
Appears to control where you park your car.
.No
The parking meter is a fairly inert scenic object.  You can drop Tokens into
it and cause it to change its state from ``EXPIRED'' to ``OK'', but this
doesn't actually \fIdo\fP anything.
.Sy
\fRNone.
.Pr
meterState      /* What state the parking meter is in.  Possible values are
                   METER_EXPIRED and METER_TICKING. */
.Cl
\fRNo class properties.
.Hp
take            /* How many tokens this parking meter has raked in. */
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
.nf
{
    \fI/* If the avatar has the money, take the price of a parking and
       set the meter running.  Otherwise, drop whatever is in hand next to the
       machine. */\fC
    if (payCoinOpOrDrop(PARKING_COST, SOUND_JINGLE,
            SOUND_CLICK_CLUNK, SOUND_JINK, goTo)) {
        self.meterState = METER_TICKING
    }
}
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(meterState)
{
    self.meterState = meterState
}
.Dy
smash()
.As
PAY* ()
{
    spend(PARKING_COST)
    soundEffect(SOUND_CLICK_CLUNK)
    self.meterState = METER_TICKING
}
EXPIRE+ ()
{
    \fI/* Asynchronous event when meter expires. */\fC
    self.meterState = METER_EXPIRED
}
.Gr
Two-state image of parking meter: expired and ticking.
.Hb
PAY () \(-> (success)
{
    if (spend(PARKING_COST)) {
        self.meterState = METER_TICKING
        scheduleEvent(MeterExpire, METER_TIME_DELAY)
        success = TRUE
        # self \(-> PAY* ()
    } else {
        success = FALSE
    }
}
MeterExpire()
{
    # self \(-> EXPIRE+ ()
    self \(-> EXPIRE+ ()
    self.meterState = METER_EXPIRED
}
.En
.Ob
pencil
.De
Your basic pencil.
.Fu
Writes on paper.
.No
The pencil object is required in order to edit the contents of a piece of
paper.  If you do not have the pencil, you may only read.  It's a magic
pencil: it never needs sharpening.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of pencil.  We may need two orientations, horizontal and
vertical, for the animation of the avatar handling it to look right.
.Hb
GET
PUT
THROW
.En
.Ob
phone booth
.De
The traditional walk-in phone booth with real-live working pay phone (the sort
which are getting rarer and rarer these days).
.Fu
Interface to the telephone system for avatars away from home.
.No
The phone booth is probably the single most complex object in the system, in
terms of its behavior.  However, it works pretty much like an ordinary pay
phone in the ``real'' world.
.Sy
\fRNone.
.Pr
phoneNumber     /* The 2-byte phone number associated with this phone */
state           /* The state that the phone is currently in.  The possible
                   states that the phone may be in at any given time are
                   PHONE_READY, PHONE_RINGING, PHONE_OFF_HOOK, PHONE_ACTIVE,
                   PHONE_TALKING, PHONE_LINE_RING and PHONE_LINE_BUSY */
.Cl
\fRNo class properties.
.Hp
talker          /* Avatar connected to this phone. */
caller          /* The phone at the other end of the line. */
take            /* Total income from this booth, in Tokens. */
beeper          /* Beeper associated with this phone.  Always NULL. */
answeringMachine /* Answering machine associated with this phone.  Always
                   NULL. */
owner           /* Avatar who owns this phone.  Always NULL. */
.Co
.Do
.nf
{
    \fI/* If in booth, hang up phone if not already hung up.  Answer if
       ringing.  Otherwise, depends. */\fC
    hangUpOrAnswer(here(self))
}
.Go
enterOrExit()
.St
cease()
.Ge
.nf
{
    \fI/* Answer the phone if it's ringing, otherwise just pick up the
       receiver. */\fC
    answerOrUnhook(here(self), PHONE_OFF_HOOK)
}
.Pu
.nf
{
    \fI/* If avatar has a token in hand, activate the phone.  If holding the
       receiver, hang up.  Otherwise drop whatever is in hand next to the
       phone booth. */\fC
    if (self.state == PHONE_READY || (here(self) && self.state ==
            PHONE_OFF_HOOK)) {
        if (payCoinOpOrDrop(PHONE_CALL_COST, SOUND_JINGLE,
                SOUND_CLICK_CLUNK, SOUND_JINK, goEnter)) {
            self.state = PHONE_ACTIVE
            soundEffect(SOUND_DIAL_TONE)
        }
    } else if (here(self) && (self.state == PHONE_LINE_BUSY || self.state ==
            PHONE_LING_RING || self.state == PHONE_TALKING)) {
        hangUp()
        soundEffect(SOUND_JANGLE)
        refund(PHONE_CALL_COST, avatar)
    }
}
.Ta
.nf
{
    \fI/* If the phone is active (from dropping a token in it), interpret text
       as a phone call: first text message is phone number, further messages
       are conversation with the person at the other end.  When you enter the
       number, the phone dials.  If there is an answer, you can talk.  If not,
       you get your tokens back (into avatar's hand) and the phone is
       deactivated when you hang up.  If phone is not active, broadcast. */\fC
    dialOrTalk(here(self))
}
.Re
/* This can't happen */
.In
.nf
init(phoneNumber, state)
{
    self.phoneNumber = phoneNumber
    self.state = state
}
.Dy
smash()
.As
ANSWERED*
ANSWER*
HANG*
HUNGUP*
UNHOOK*
RING*
DIAL*
SPEAK*
.Gr
Single static image of phone booth.  Cel for receiver so we can show it in the
avatar's hand.  Sound of phone in booth ringing.  Sound of phone ringing at
other end of phone line.  Busy signal sound.  Dial tone.  Dialing sounds
(touch tones or rotary clanks).  Clicking and clunking when the receiver is
picked up or hung up or when the person at the other end hangs up.  Sounds of
coins being deposited, refunded and swallowed.
.Hb
ANSWER
DIAL
HANG
PAY () \(-> (success)
{
    if (spend(PHONE_CALL_COST) && self.state == PHONE_OFF_HOOK) {
        self.state = PHONE_ACTIVE
        success = TRUE
    } else {
        success = FALSE
    }
}
TALK
UNHOOK
.En
.Ob
picture
.De
A picture to display.
.Fu
Displays artwork or text on wall or in space.
.No
A picture is represented by a set of imagery that is part of its state
information.  Due to the large overhead associated with such objects, pictures
will have to be either small or infrequent.
.Sy
\fRNone.
.Pr
size            /* How big the picture is.  This is a binary value: TRUE if
                   the picture is too large for an avatar to pick up. */
picture         /* The contents of the picture, represented as a conventional
                   MicroCosm graphic (except that the data comes from the host
                   rather than from the internal object definitions. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* Grab it if you can (if it's not too big). */\fC
    if (goTo()) {
        if (!size) {
            get()
        }
    }
}
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(size, \fIpicture\fC)
{
    self.size = size
    self.picture = \fIpicture\fC
}
.Dy
smash()
.As
\fRNone.
.Gr
A single static image which is rendered out of the \fCpicture\fR state
variable.
.Hb
GET   \fB/* *** Need special check to handle size. *** */\fC
PUT
THROW
.En
.Ob
plant
.De
Your basic generic plant.
.Fu
Scenic element.  Obstruction.
.No
This is a fairly inert scenic element, provided almost entirely for visual
appeal.  We may wish to consider giving certain styles of plants magical powers
(healing, etc.) in addition, but such uses are not addressed here.
.Sy
PLANT_WEED, PLANT_GRASS, PLANT_FLOWER, PLANT_REED, PLANT_VINE, PLANT_GRAIN
.Pr
uprootable      /* Flag whether or not plant can be uprooted by hand */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* Get the plant, but only if it is uprootable */\fC
    if (self.uprootable) {
        goToAndGet()
    } else {
        goTo()
    }
}
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(plantStyle, uprootable)
{
    self.grstyle = plantStyle
    self.uprootable = uprootable
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image for each style of plant.
.Hb
GET  \fB/* *** Need special check for uprootability *** */\fC
PUT
THROW
.En
.Ob
pond
.De
A small (within the region) body of water.
.Fu
Water source.  Water obstruction.
.No
\fB*** We need to figure out how we are going to indicate where the pond is
and where it is not. ***\fR
.Sy
\fRNone.
.Pr
coverage        /* Somehow indicate what areas the pond covers */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndFill()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(\fIcoverage\fC)
{
    self.coverage = \fIcoverage\fC
}
.Dy
nullDestroy()
.As
\fRNone.
.Gr
Pond image on ground, rendered during background processing.
.Hb
\fRNone.
.En
.Ob
radio
.De
Your basic boom box.
.Fu
Lets us hear the local radio station.
.No
The radio only receives one channel, \fIRadio Free MicroCosm\fR.  When the
radio is turned on, it plays whatever is on the radio at the time.  When it is
off it does nothing.
.Sy
\fRNone.
.Pr
on              /* Flag that the radio is on.  TRUE if it is. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    if (!toggleSwitch(!elsewhere(self))) {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(on)
{
    self.on = on
}
.Dy
smash()
.As
OFF*
ON*
PLAY+ (\fIscore\fC)
{
    \fI/* Asynchronous function when something comes in to be played. */\fC
    \fB/* *** Trigger this. *** */\fC
    playMusic(\fIscore\fC)
}
ANNOUNCE+ (\fItext\fC)
{
    \fI/* Asynchronous function when an announcement comes over the radio. */\fC
    \fB/* *** Trigger this. *** */\fC
     balloonMessage(self, "%s", \fItext\fC)
     playSpeech(\fItext\fC)
}
.Gr
.Hb
GET
OFFPLAYER
ONPLAYER
PUT
THROW
.En
.Ob
region
.De
A place in the world.
.Fu
The basic building block of \fBMicroCosm\fP topography.
.No
The region is not really an object, but we have an object that represents it
so that the host can send messages to it.  Basically, all it does is contain
things.  It also has a few other properties that are used for background
graphics rendering.  Note that some of the region's generic properties are
interpreted slightly differently.  In particular, the \fCy\fP position encodes
the vertical screen position of the horizon line.
.Sy
REGION_PLAIN, REGION_URBAN, REGION_FOREST, REGION_DESERT, REGION_INTERIOR
.Pr
contents        /* A list of the objects in the region. */
width           /* Width of the region, in feet. */
depth           /* Depth of the region, in feet. */
classGroup      /* Region-specific object class partition associate with this
                   region (i.e., which set of 128 region-specific object
                   classes do we use here?). */
avatar          /* Which avatar in the region represents the player. */
.Cl
\fRNo class properties.
.Hp
exclusion       /* Flag that entry to this region is blocked by security
                   device. */
regionNumber    /* The 2-byte identifier associated with this region. */
connectivity[4] /* The other regions West, East, North and South of here. */
.Co
\fRNone: it is not a selectable object on the screen.
.In
.nf
init(terrainStyle, horizon, width, depth, regionNumber, classGroup, \fIcontentsVector\fC)
{
    self.grstyle = terrainStyle
    self.horizon = horizon
    self.width = width
    self.depth = depth
    self.regionNumber = regionNumber
    self.classGroup = classGroup
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
nullDestroy()
.As
\fRNone.
.Gr
None.  Everything falls out of the objects that are here.
.Hb
DESCRIBE () \(-> (\fIregionDescriptor\fC)
{
	\fIregionDescriptor\fC = vectorize(self);
}
.En
.Ob
ring
.De
Your basic magic ring.
.Fu
Generic magic talisman.
.No
Rings are always magical.  A ring will do something special and powerful.  The
magical function may vary.  \fB*** The set of magical functions needs thought.
***\fP  Rings are extremely rare and contain unusually powerful forms of magic
(not always good).  The general function of a ring will be to confer some
particular power or ability on the avatar wearing it.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
location = HAND /* Where this is worn. */
.Hp
magicType       /* What sort of magic this ring contains.  Used as case
                   switch for execution of magical behavior. */
.Co
.Do
doMagic()
.Go
goTo()
.St
cease()
.Ge
wear()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smallExplosion()
.As
\fRNone.
.Gr
Single static image of ring.  Cels for ring on avatar's finger in front, back
and side views.
.Hb
GET
MAGIC
PUT
THROW
.En
.Ob
river
.De
Body of water flowing through a region.
.Fu
Water source.  Linear water obstruction.
.No
This poses essentially the same problem that the pond does: how do we indicate
where the water is and where it is not?  We may, in fact, want to merge the
mechanisms of the two so that there is just a single type of body-of-water
object.  However, for rivers we may want to have currents so things will
drift (\fB*** unsolved problem ***\fR).
.Sy
\fRNone.
.Pr
path            /* Somehow indicate where the river flows */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.Stop
cease()
.Ge
goToAndFill()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(\fIpath\fC)
{
    self.path = \fIpath\fC
}
.Dy
nullDestroy()
.As
\fRNone.
.Gr
River image on ground, rendered during background processing.
.Hb
\fRNone.
.En
.Ob
rock
.De
Your basic rock.
.Fu
Scenic element.  If small can be picked up, thrown.
.No
Rocks are mostly for visual variation, but can also be used as weapons.
.Sy
ROCK_SMALL, ROCK_MEDIUM, ROCK_LARGE, ROCK_HUGE
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* Get the rock if it's not too heavy. */\fC
    if (self.grstyle == ROCK_SMALL || self.grstyle == ROCK_MEDIUM) {
        goToAndGet()
    } else {
        goTo()
    }
}
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(weight)
{
    self.weight = weight
}
.Dy
smash()
.As
\fRNone.
.Gr
One static image of rock for each weight.  Sound of rock hitting something.
.Hb
GET   \fB/* *** Need special check to handle weights. *** */\fC
PUT
THROW
.En
.Ob
roof
.De
The roof of a building.
.Fu
Graphic element in buildings.
.No
A roof is a single trapezoid that sits on top of a building.  Roof objects are
not found in isolation but only as components of building objects.  It is a
fairly inert background object.  Once painted on the background it is of
little consequence except visually.  Unlike ground and sky, which are
pseudo-objects, roof objects really exist, but they are not known to the host,
since they never take part in any host interactions.  Rather, they are created
internally by building objects (which \fIare\fP known to the host).
.Sy
ROOF_FLAT, ROOF_GABLED, ROOF_A_FRAME
.Pr
size            /* How big the roof is.  This is basically a length.  The
                   height is determined algorithmically from this value and
                   from the style of roof that it is. */
base            /* How high above the ground the bottom of the roof starts. */
roofPattern     /* The color and texture that the roof appears. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
noEffect()
.St
cease()
.Ge
noEffect()
.Pu
noEffect()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(roofStyle, size, base, roofPattern)
{
    self.grstyle = roofStyle
    self.size = size
    self.base = base
    self.roofPattern = roofPattern
}
.Dy
nullDestroy()
.As
\fRNone.
.Gr
Roof image as part of building, rendered by background processor when it draws
the whole building.  It is drawn as a texture mapped trapezoid (ROOF_FLAT
comes out as a rectangle, ROOF_GABLED comes out as a trapezoid and
ROOF_A_FRAME comes out as a triangle).  Note that roofs are always viewed
face-on, never edge-wise.
.Hb
\fRNone.
.En
.Ob
rubber ducky
.De
Your basic bathtub toy.
.Fu
To amuse people in the hot tub.
.No
This object doesn't actually do anything (yet).
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of rubber ducky.
.Hb
GET
PUT
THROW
.En
.Ob
safe
.De
Your basic office or household safe.
.Fu
Stores things under lock and key.
.No
The safe is both a piece of furniture, for scenic purposes, and a container.
It has two states, open and closed, and it can be locked.  When it is open,
anyone in the region can see the contents, thus a safe may only be opened if
there are enough free object identifiers available to identify the complete
contents to all the players.  The safe operates just like a chest of drawers
with the exception that it can be locked.
.Sy
\fRNone.
.Pr
contents        /* Contents list: a list of the objects that the safe
                   contains.  This will always be NULL if the safe is
                   closed. */
open            /* Flag telling whether the safe is open.  TRUE if open. */
key             /* Two-byte number indicating the key required for this
                   safe. */
unlocked        /* Flag that lock is unlocked.  TRUE if it is. */
.Cl
capacity = ?            /* How many things this can hold. */
displayContents = FALSE /* Whether to show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
adjacentOpenCloseContainer()
.Go
goTo()
.St
cease()
.Ge
goToAndPickFromIfOpen()
.Pu
goToAndDropIntoIfOpen()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(open, key, unlocked, \fIcontentsVector\fC)
{
    self.open = open
    self.key = key
    self.unlocked = unlocked
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Two-state image of safe: safe open and safe closed.
.Hb
CLOSECONTAINER
OPENCONTAINER
.En
.Ob
security device
.De
Another miscellaneous gadget.
.Fu
Provides a way to make a region safe from intrusion.
.No
The security device provides a way to protect your avatar and property from
harm.  When the security device is turned on, no one else can enter or leave
the region it is in.  It only works in selected regions (like hotel rooms).
The device indicates its operation by means of both an indicator light and a
humming sound.
.Sy
\fRNone.
.Pr
on              /* Flag that device is turned on. TRUE if it is. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    if (!toggleSwitch(!elsewhere(self))) {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(on)
{
    self.on = on
}
.Dy
mediumExplosion()
.As
OFF*
ON*
.Gr
Two-state image of device with indicator light on and off.  Also, humming
sound when it is on.
.Hb
GET
OFF () \(-> ()
{
    if (!elsewhere(self) && self.on) {
        self.on = FALSE
        region.exclusion--
        # self \(-> OFF* ()
    }
}
ON () \(-> ()
{
    if (!elsewhere(self) && !self.on) {
        self.on = TRUE
        region.exclusion++
        # self \(-> ON* ()
    }
}
PUT
THROW
.En
.Ob
sensor
.De
Another miscellaneous gadget.
.Fu
Tells some property of a region, object or avatar.
.No
The sensor can scan for information which is not always directly perceptible
to an avatar or, for that matter, to the player's home system.  What it scans
for depends on what type of sensor it is.  For example, a weapon sensor will
tell if any of the avatars in the region is carrying a weapon, even if the
weapon is inside a backpack or similar container.  The sensing is performed by
the host, so it is guaranteed to be ``honest''.  \fB*** The set of things that
sensors sense needs further thought. ***\fP
.Sy
SENSOR_WEAPON, SENSOR_LIFE_REMOTE, SENSOR_MAGIC, SENSOR_MAGIC_REMOTE, etc.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
.nf
{
    \fI/* Do a scan with the detector and make a sound appropriate to what was
       found. */\fC
    if (!elsewhere(self)) {
        @ self!SCAN () \(-> (detection)
        if (detection) {
            soundEffect(SOUND_DETECT)
        } else {
            soundEffect(SOUND_NO_DETECT)
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(sensorStyle)
{
    self.grstyle = sensorStyle
}
.Dy
smash()
.As
SCAN* (detection)
{
    if (detection) {
        soundEffect(SOUND_DETECT)
    } else {
        soundEffect(SOUND_NO_DETECT)
    }
}
.Gr
Single static image of sensor.  Sounds of detection and non-detection.
.Hb
GET
PUT
SCAN () \(-> (detection)
{
    if (holding(self)) {
        detection = (*sensorActions[self.style])()
        # self \(-> SCAN* (detection)
    } else {
        detection = FALSE
    }
}
THROW
.En
.Ob
shirt
.De
Your basic shirt.
.Fu
Decorative.  Helps distinguish one avatar from another.
.No
A shirt is a clothing object whose only purpose is to personalize avatars.  A
shirt operates like a jacket, except that it has no pockets.  Unlike the real
world, it is not possible to wear a shirt and a jacket at the same time.
There are a couple of different styles of shirts.
.Sy
SHIRT_T, SHIRT_LONG_SLEEVE, SHIRT_SHORT_SLEEVE
.Pr
pattern         /* The pattern the shirt cels should be painted with. */
.Cl
location = TORSO /* Where this is worn. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
wear()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(shirtStyle, pattern)
{
    self.grstyle = shirtStyle
    self.pattern = pattern
}
.Dy
smash()
.As
\fRNone.
.Gr
For each style of shirt, a single static image of shirt in heap, plus avatar
animation cels showing shirt on torso in front, side and back views.
.Hb
GET
PUT
THROW
.En
.Ob
shoes
.De
A pair of shoes.
.Fu
Decorative.  Helps distinguish one avatar from another.
.No
A pair of shoes is a clothing object whose only purpose is to personalize
avatars.  It is represented by a couple of cels that simply follow the
avatar's feet.
.Sy
SHOES_RUNNING, SHOES_DRESS, SHOES_BOOTS
.Pr
\fRNo properties.
.Cl
location = FEET         /* Where this is worn. */
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
wear()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(shoeStyle)
{
    self.grstyle = shoeStyle
}
.Dy
smash()
.As
\fRNone.
.Gr
Cels of shoes for each style of shoes in side, front and back views.
.Hb
GET
PUT
THROW
.En
.Ob
sidewalk
.De
Your basic suburban sidewalk.
.Fu
Scenic element.  Can be walked on (keeps feet off the lawn!).
.No
Each sidewalk object is a single trapezoid of sidewalk material.  The sides
are always parallel to the edges of the region.  It is a fairly inert
background object.  Once painted on the ground, it is of no consequence except
visually, and behaves exactly like ground.  Whether we in fact wish to have it
disappear once painted on the ground and have the ground behavior come into
play when sidewalk is pointed at or whether we want to simply have it execute
exactly the same behavior protocol as ground is unclear.
.Sy
\fRNone.
.Pr
width           /* Section width from the corner */
height          /* Section length from the corner */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goToCursor()
.St
cease()
.Ge
noEffect()
.Pu
goToCursorAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(width, height)
{
    self.width = width
    self.height = height
}
.Dy
nullDestroy()
.As
\fRNone.
.Gr
Sidewalk image on ground, rendered during background processing, as a single,
texture-mapped trapezoid.
.Hb
\fRNone.
.En
.Ob
sign
.De
A standard sign.
.Fu
For public safety and information.
.No
The sign is a fairly inert scenic object, provided almost entirely for visual
appeal.
.Sy
SIGN_EXIT, SIGN_BILLBOARD, SIGN_FOR_SALE
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of sign (front view).
.Hb
\fRNone.
.En
.Ob
skateboard
.De
Your basic skateboard.
.Fu
Carries one avatar in a silly manner.
.No
The skateboard is a vehicle that can travel on roads and sidewalks.  It can
only carry one avatar and it can't carry any other objects except what is
already on the avatar's person.
.Sy
\fRNone.
.Pr
inhabitants[SKATE_SIZE] /* The avatar riding in it.  This is NULL if there is
                   no rider. */
moving          /* A flag that the skateboard is in motion. */
targetX         /* Motion destination X position. */
targetY         /* Motion destination Y position. */
.Cl
maxOccupants = SKATE_SIZE = 1
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
climbInOrOut()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(moving, targetX, targetY, inhabitant)
{
    self.moving = moving
    self.targetX = targetX
    self.targetY = targetY
    self.inhabitants[0] = inhabitant
}
.Dy
smash()
.As
WALK*
.Gr
Three static images of skateboard: side view, front view and back view.
.Hb
GET
PUT
THROW
.En
.Ob
skirt
.De
Your basic skirt.
.Fu
Decorative.  Helps distinguish one avatar from another.
.No
Skirt are items of clothing whose primary purpose is to personalize avatars.
They also have pockets, which are useful for holding things without resorting
to hands.   There is only one sort of skirt, but it comes in a variety of
patterns.  Skirts function exactly like pants, except that they are perhaps
more appropriate for a female avatar.
.Sy
\fRNone.
.Pr
pattern         /* The pattern the skirt cels should be painted with. */
contents        /* A list of the objects in the skirt's pockets.  NULL if the
                   pockets are empty. */
.Cl
location = LEGS         /* Where this is worn. */
capacity = ?            /* How many things this can hold. */
displayContents = FALSE /* Whether to show what's in it. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
wearOrUnpocket()
.Pu
remove()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(pattern, \fIcontentsVector\fC)
{
    self.pattern = pattern
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
Single static image of skirt in heap, plus avatar animation cels showing skirt
on legs in front, side and back views.
.Hb
GET
PUT
THROW
.En
.Ob
sky
.De
The basic background above the horizon.
.Fu
Can be pointed at, returning a location.
.No
This is not really an object, but is treated as one to make the player
interface clean.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
noEffect()
.St
cease()
.Ge
noEffect()
.Pu
noEffect()
.Ta
broadcast()
.Re
/* This can't happen */
.In
nullInit()
.Dy
nullDestroy()
.As
\fRNone.
.Gr
Blue (or other sky color) from top of graphics window to the scenic horizon.
Scenic background color from scenic horizon down to the true horizon.  Scenic
background horizon line is a jaggy line procedurally determined from the
terrain style.  Drawn by the background rendering initialization routines.
.Hb
\fRNone.
.En
.Ob
stereo
.De
Your basic tape deck.
.Fu
Plays music of your choice.
.No
The stereo is like the radio, but instead of playing whatever comes over the
``air'' it plays tapes.  Tapes contain specific pieces of music which the host
knows about.
.Sy
\fRNone.
.Pr
on              /* Flag that stereo is playing.  TRUE if it is. */
tape            /* What tape is in the stereo.  NULL if none is. */
.Cl
capacity = 1    /* Can only hold 1 tape. */
displayContents = FALSE /* Whether to show tape. */
.Hp
playPointer     /* Where we are in the current tape. */
.Co
.Do
.nf
{
    if (!toggleSwitch(holding(self))) {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* If holding the stereo, pop the tape out.  Otherwise, get it. */\fC
    if (holding(self) && !self.on) {
        if (self.tape != NULL) {
            changeContainers(self.tape, region, avatar.x, avatar.y)
            self.tape = NULL
            @ self!UNLOAD () \(-> ()
        }
    } else {
        goToAndGet()
    }
}
.Pu
.nf
{
    \fI/* If holding a tape and the stereo has none, put the tape in the
       stereo.  Otherwise, just drop whatever next to the stereo. */\fC
    if (holdingClass(TAPE_CLASS) && self.tape == NULL && !self.on && goTo()) {
        @ self!LOAD (avatar.inHand.noid) \(-> (success)
        if (success) {
            avatar.action = PUT
            subjectObject = avatar.inHand
            changeContainers(avatar.inHand, self, NULL, TAPE)
        }
    } else {
        goToAndDropAt()
    }
}
.Ta
broadcast()
.Re
throw()
.In
.nf
init(on, tape)
{
    self.on = on
    self.tape = tape
}
.Dy
smash()
.As
PLAY+ (\fIscore\fC)
{
    \fI/* Asynchronous function when something comes in to be played. */\fC
    \fB/* *** Trigger this. *** */\fC
    if (self.on) {
        playMusic(\fIscore\fC)
    }
}
.Gr
Single static image of tape deck.
.Hb
GET
LOAD (tapeId) \(-> (success)
{
    tape == \(uatapeId
    if (holding(tape) && tape.class == TAPE_CLASS && adjacent(self)
            && !self.on && self.tape == NULL) {
        self.tape = tape
        changeContainers(tape, self, NULL, TAPE)
        success = TRUE
    } else {
        success = FALSE
    }
}
OFFPLAYER
ONPLAYER
PUT
THROW
UNLOAD () \(-> ()
{
    if (holding(self) && !self.on && self.tape != NULL) {
        changeContainers(self.tape, region, avatar.x, avatar.y)
        self.tape = NULL
    }
}
.En
.Ob
street
.De
Your basic roadway.
.Fu
Can be walked on.  Carries ground vehicles.
.No
Each street object is a single trapezoid of street material.  The sides are
always parallel to the edges of the region.  It is relatively inert, like
sidewalk, but does have some special properties.  It behaves just like ground.
However, cars can only drive on the surfaces of streets (unless they are
special, off-road vehicles), and so in that sense it is special.
.Sy
\fRNone.
.Pr
width           /* Section width from the corner */
height          /* Section length from the corner */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goToCursor()
.St
cease()
.Ge
noEffect()
.Pu
goToCursorAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(width, height)
{
    self.width = width
    self.height = height
}
.Dy
nullDestroy()
.As
\fRCars may drive on streets.  (They may not drive on other sorts of surfaces.)
.Gr
Road image on ground, rendered during background processing, as a single,
texture-mapped trapezoid.
.Hb
\fRNone.
.En
.Ob
streetlamp
.De
Conventional streetlamp.
.Fu
Scenic element.  Provides light at night.
.No
The \fBMicroCosm\fP follows a cycle of day and night.  When it is night-time,
the screen is displayed in darkened colors, which makes things hard to see.
Having a streetlamp in the region makes the region appear like daytime, even
if it is night elsewhere.
.Sy
STREETLAMP_GASLIGHT, STREETLAMP_MODERN
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(lampStyle)
{
    self.grstyle = lampStyle
}
.Dy
.nf
{
    smash()
    lightLevel--
}
.As
\fRNone.
.Gr
A single static image for each style of streetlamp.
.Hb
\fRNone.
.En
.Ob
table
.De
A common table.
.Fu
Can support things (hold them off the floor).
.No
The table is a form of container whose contents are always visible and
accessible (i.e., it is permanently ``open'').  Things can be placed on it and
picked up off of it.
.Sy
TABLE_KITCHEN, TABLE_COFFEE, TABLE_DINING
.Pr
contents        /* Contents list: a list of the objects on the table.  */
.Cl
capacity = ?            /* How many things this can hold. */
displayContents = TRUE  /* Whether to show what's in this. */
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndPickFrom()
.Pu
goToAndDropOnto()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(tableStyle, \fIcontentsVector\fC)
{
    self.grstyle = tableStyle
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smashWithContents()
.As
\fRNone.
.Gr
A single static image of a table for each table style.
.Hb
\fRNone.
.En
.Ob
tape
.De
A cassette tape.
.Fu
Can be played in the stereo tape deck.
.No
The tape simply serves to identify which piece of music the stereo should
play.
.Sy
\fRNone.
.Pr
music           /* 2-byte identifier telling what music is on this tape. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
.nf
{
    \fI/* If holding the tape, read the label.  Otherwise depends. */\fC
    if (holding(self)) {
        @ self!READLABEL () \(-> (\fItext\fC)
        balloonMessage(self, "%s", \fItext\fC)
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(music)
{
    self.music = music
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of tape cassette.
.Hb
GET
PUT
READLABEL () \(-> (\fItext\fC)
{
    if (holding(self)) {
        \fItext\fC = music[self.music]->\fIlabel\fC
    } else {
        \fItext\fC = ""
    }
}
THROW
.En
.Ob
teddy bear
.De
A soft, cuddly teddy bear.
.Fu
A great security enhancer.
.No
This is the most valuable item in the \fBMicroCosm\fP, as there is only one of
them.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
mediumExplosion()
.As
\fRNone.
.Gr
Single static image of teddy bear.
.Hb
GET
PUT
THROW
.En
.Ob
telephone
.De
The household telephone.
.Fu
Remote communications with other players on-line.
.No
The household telephone operates similarly to the phone booth pay-phone, but
it is not so complicated because it doesn't have to collect money from the
player in order to work.
.Sy
\fRNone.
.Pr
phoneNumber     /* The 2-byte phone number associated with this phone */
state           /* The state that the phone is currently in.  The possible
                   states that the phone may be in at any given time are
                   PHONE_READY, PHONE_RINGING, PHONE_ACTIVE, PHONE_TALKING,
                   PHONE_LINE_RING and PHONE_LINE_BUSY */
.Cl
\fRNo class properties.
.Hp
talker          /* The avatar currently connected to this phone. */
caller          /* The phone at the other end of the line. */
beeper          /* Beeper associated with this phone. */
answeringMachine /* Answering machine associated with this phone. */
owner           /* Avatar associated with this phone. */
.Co
.Do
.nf
{
    \fI/* If at phone, hang it up if not already hung up.  Answer if ringing.
        Otherwise, depends. */\fC
    hangUpOrAnswer(!elsewhere(self))
}
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* Answer the phone if it's ringing, otherwise just pick up the
       receiver. */\fC
    answerOrUnhook(goTo(), PHONE_ACTIVE)
}
.Pu
.nf
{
    \fI/* If holding the receiver, hang up.  Otherwise drop whatever is in
       hand next to the phone. */\fC
    if (!elsewhere(self) && (self.state == PHONE_ACTIVE || self.state ==
            PHONE_LINE_BUSY || self.state == PHONE_LING_RING || self.state ==
            PHONE_TALKING)) {
        hangUp()
    } else {
        goToAndDropAt()
    }
}
.Ta
.nf
{
    \fI/* If the phone is active, interpret text as a phone call: first text
       message is phone number, further messages are conversation with the
       person at the other end.  When you enter the number, the phone dials.
       If there is an answer, you can talk.  If not, the phone is deactivated
       when you hang up.  If phone is not active, broadcast. */\fC
    dialOrTalk(!elsewhere(self))
}
.Re
/* This can't happen */
.In
.nf
init(phoneNumber, state)
{
    self.phoneNumber = phoneNumber
    self.state = state
}
.Dy
smash()
.As
ANSWERED*
ANSWER*
HANG*
HUNGUP*
UNHOOK*
RING*
DIAL*
SPEAK*
.Gr
Single static image of phone.  Cel for receiver so we can show it in the
avatar's hand.  Sound of phone ringing.  Sound of phone ringing at other end
of phone line.  Busy signal sound.  Dial tone.  Dialing sounds (touch tones or
rotary clanks).  Clicking and clunking when the receiver is picked up or hung
up or when the person at the other end hangs up.
.Hb
ANSWER
DIAL
HANG
TALK
UNHOOK
.En
.Ob
teleport booth
.De
Like a phone booth, but it carries all of you instead of just your voice.
.Fu
Zaps avatars and their possessions elsewhere instantaneously.
.No
The teleport booth is fairly complex.  However, it operates very much like a
pay phone.  The only difference is that you get transported to the
destination.  This means that you don't have to wait for somebody to answer or
suffer a busy signal: you just go.  It is also more expensive than a phone
call.
.Sy
\fRNone.
.Pr
boothNumber     /* The 2-byte port number associated with this port. */
state           /* The state that the port is currently in.  The possible
                   states are PORT_READY and PORT_ACTIVE. */
.Cl
\fRNo class properties.
.Hp
take            /* Total income from this booth, in Tokens. */
.Co
.Do
depends()
.Go
enterOrExit()
.St
cease()
.Ge
noEffect()
.Pu
.nf
{
    \fI/* If avatar has a token in hand and the port is not already active,
       activate the port.  Otherwise drop whatever is in hand next to the
       booth. */\fC
    if (self.state == PORT_READY) {
        if (payCoinOpOrDrop(TELEPORT_COST, SOUND_JINGLE,
                SOUND_CLUNK_BUZZ, SOUND_JINK, goEnter)) {
            self.state = PORT_ACTIVE
            soundEffect(SOUND_DIAL_TONE)
        }
    }
}
.Ta
.nf
{
    \fI/* If the teleporter is active (from dropping a token in it),
       interpret text as a teleport booth number, and teleport the avatar and
       everything he is carrying to the teleport booth dialed.  If the booth
       is not active, broadcast. */\fC
    if (here(self) && self.state == PORT_ACTIVE) {
        @ self!ZAPTO (\fItext\fC) \(-> (success)
        soundEffect(SOUND_DIAL, \fItext\fC)
        if (success) {
            self.state = PORT_READY
            soundEffect(SOUND_ZAP_OUT)
        }
    } else {
        broadcast()
    }
}
.Re
/* This can't happen */
.In
.nf
init(boothNumber, state)
{
    self.boothNumber = boothNumber
    self.state = state
}
.Dy
mediumExplosion()
.As
PAY* ()
{
    spend(TELEPORT_COST)
    soundEffect(SOUND_CLUNK_BUZZ)
    self.state = PORT_ACTIVE
    soundEffect(SOUND_DIAL_TONE)
}
ZAPTO* (avatar)
{
    self.state = PORT_READY
    soundEffect(SOUND_ZAP_OUT)
}
ZAPIN* ()
{
    \fI/* Asynchronous function when somebody arrives from someplace else. */\fC
    \fB/* *** Trigger this. *** */\fC
    soundEffect(SOUND_ZAP_IN)
}
.Gr
Single static image of teleport booth.  Sound of dialing.  Sound of yourself
zapping out to someplace else.  Sound of somebody else zapping in from
elsewhere.
.Hb
PAY () \(-> (success)
{
    if (self.state == PORT_READY && spend(TELEPORT_COST)) {
        self.state = PORT_ACTIVE
        success = TRUE
        # self \(-> PAY* ()
    } else {
        success = FALSE
    }
}
ZAPTO (\fItext\fC) \(-> (success)
{
    if (here(self) && self.state == PORT_ACTIVE) {
        destination = lookupTeleportAddress(\fItext\fC)
        if (destination != NULL) {
            goToNewRegion(avatar, destination)
            success = TRUE
            self.state = PORT_READY
            # self \(-> ZAPTO* (avatar.noid)
        } else {
            success = FALSE
        }
    } else {
        success = FALSE
    }
}
.En
.Ob
ticket
.De
A ticket to the show.
.Fu
Your avatar's admission to special events.
.No
Tickets are used to control admission to certain regions.  You have to have
the ticket that corresponds to an event in such a regions in order to be let
in.
.Sy
\fRNone.
.Pr
event           /* What event this ticket is admission for. */
.Cl
\fRNo class properties.
.Hp
\fRNo additional properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
.nf
init(event)
{
    self.event = event
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of ticket.
.Hb
GET
PUT
THROW
.En
.Ob
tokens
.De
Filthy lucre.
.Fu
Money in the MicroCosm.
.No
The standard unit of currency in the \fBMicroCosm\fP is the Token.  On one
side it says \fIGood For One Fare\fR.  On the other side it says \fIFiat
Lucre\fR.  A single token object can denote any amount of money.  The
\fCdenomination\fP property tells how much money a token is currently
representing.  Certain machines in the \fBMicroCosm\fP world are coin
operated.  Dropping a token into them will cause the appropriate amount of
money to be consumed.  If there is any left over it is left in the avatar's
hand.  Other sorts of transactions require that the quantity be specified by
the player.  You can open up a token almost as if it was a container object
and interactively select the amount of money you wish to extract.  A second
token object is created with this denomination and placed wherever indicated,
while the first token object has its denomination reduced accordingly and is
left in the player's hand.
.Sy
\fRNone.
.Pr
denomination    /* How much money this token represents. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
.nf
{
    \fI/* Select an amount of money and fork it over. */\fC
    amount = selectDenomination(self.denomination)
    @ self!PAY (target, amount) \(-> (success, actualTarget, x, y)
    if (success) {
        self.denomination -= amount
        if (self.denomination == 0) {
            destroyObject(self)
        }
        if (actualTarget.class == TOKEN_CLASS) {
            actualTarget.denomination += amount
        } else {
            newToken = createObject(TOKEN_CLASS, actualTarget, x, y)
            newToken.denomination = amount
        }
        soundEffect(SOUND_JINGLE)
        avatar.action = PUT
    }
}
.In
.nf
init(denomination)
{
    self.denomination = denomination
}
.Dy
smash()
.As
PAID* (amount)
{
    self.denomination += amount
}
.Gr
Single static image of a coin.  Sound of coins jingling.
.Hb
GET
PAY (targetId, amount) \(-> (success, actualTarget, x, y)
{
    target = \(uatargetId
    if (spend(amount)) {
        if (target.class == AVATAR_CLASS) {
            if (emptyHanded(target)) {
                createObject(TOKEN_CLASS, target, NULL, HAND)
                target.inHand.denomination = amount
                actualTarget = target.inHand.noid
                x = 0
                y = 0
                announceObject(target.inHand)
            } else if (target.inHand.class == TOKEN_CLASS) {
                target.inHand.denomination += amount
                target.inHand \(-> PAID* (amount)
            }
        } else {
            newToken = createObject(TOKEN_CLASS, region, target.x, target.y)
            newToken.denomination = amount
            actualTarget = region.noid
            x = target.x
            y = target.y
            announceObject(newToken)
        }
        success = TRUE
    } else {
        success = FALSE
    }
}
PUT
.En
.Ob
towel
.De
Your basic towel.
.Fu
Necessary for every traveler.
.No
Everyone knows that this is the single most useful object you can have.
.Sy
\fRNone.
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smash()
.As
\fRNone.
.Gr
Single static image of towel.
.Hb
GET
PUT
THROW
.En
.Ob
tree
.De
Your basic tree.
.Fu
Scenic element.  Obstruction.
.No
This is a fairly inert scenic element, provided almost entirely for visual
appeal.
.Sy
TREE_CONIFER_LARGE, TREE_CONIFER_MEDIUM, TREE_CONIFER_SMALL, TREE_LEAFY_LARGE,
TREE_LEAFY_MEDIUM, TREE_LEAFY_SMALL, TREE_PALM
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(treeStyle)
{
    self.grstyle = treeStyle
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image.  Variations possible.
.Hb
\fRNone.
.En
.Ob
truck
.De
A big truck.
.Fu
Carries lots of objects along roads.
.No
The truck is a vehicle that can travel on roads.  A truck can never travel off
the road.  In other respects it is like a car, except that it has an enormous
cargo capacity.
.Sy
\fRNone.
.Pr
contents        /* A list of the objects in the truck.  NULL if there are
                   none. */
inhabitants[TRUCK_SIZE] /* The folks riding in it.  There are two slots which
                   are NULL if unoccupied.  The avatar in slot 0 gets to
                   drive. */
moving          /* A flag that the truck is in motion. */
targetX         /* Motion destination X position. */
targetY         /* Motion destination Y position. */
.Cl
capacity = ?            /* How many things this can hold. */
displayContents = FALSE /* Whether to show what's in it. */
maxOccupants = TRUCK_SIZE = 2
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
climbInOrOut()
.St
cease()
.Ge
goToAndPickFrom()
.Pu
goToAndDropIn()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(moving, targetX, targetY, inhabitants, \fIcontentsVector\fC)
{
    self.moving = moving
    self.targetX = targetX
    self.targetY = targetY
    for (i=0; i<TRUCK_SIZE; ++i) {
        self.inhabitants[i] = inhabitants[i]
    }
    unpackContentsVector(self, \fIcontentsVector\fC)
}
.Dy
smash()
.As
DRIVE*
.Gr
Three static images of truck: side view, front view, back view.  Sound of
truck engine driving.
.Hb
\fRNone.
.En
.Ob
walkie-talkie
.De
A radio telephone.
.Fu
Like a telephone, but portable.
.No
The walkie-talkie operates like a household telephone.  The only difference is
that it is portable.  The receiver is not separate and you have to be holding
it in order to operate it.
.Sy
\fRNone.
.Pr
phoneNumber     /* The 2-byte phone number associated with this phone */
state           /* The state that the phone is currently in.  The possible
                   states that the phone may be in at any given time are
                   PHONE_READY, PHONE_RINGING, PHONE_ACTIVE, PHONE_TALKING,
                   PHONE_LINE_RING and PHONE_LINE_BUSY */
.Cl
\fRNo class properties.
.Hp
talker          /* The avatar currently connected to this walkie-talkie. */
caller          /* The phone at the other end of the line. */
beeper          /* Beeper associated with this walkier-talkie.  Always
                   NULL. */
answeringMachine /* Answering machine associated with this walkie-talkie.
                   Always NULL. */
owner           /* Avatar associated with this walkie-talkie.  Always NULL. */
.Co
.Do
.nf
{
    \fI/* If holding walkie-talkie, hang it up if not already hung up.  Answer
       if ringing.  Otherwise, depends. */\fC
    hangUpOrAnswer(holding(self))
}
.Go
goTo()
.St
cease()
.Ge
.nf
{
    \fI/* Answer the phone if it's ringing, otherwise just pick up the
       receiver. */\fC
    answerOrUnhook(goToAndGet(), PHONE_ACTIVE)
}
.Pu
.nf
{
    \fI/* If off hook, hang up.  Otherwise drop whatever is in hand next to
       the walkie-talkie. */\fC
    if (holding(self) && (self.state == PHONE_ACTIVE || self.state ==
            PHONE_LINE_BUSY || self.state == PHONE_LING_RING || self.state ==
            PHONE_TALKING)) {
        hangUp()
    } else {
        goToAndDropAt()
    }
}
.Ta
.nf
{
    \fI/* If active, interpret text as a phone call: first text message is
       phone number, further messages are conversation with the person at the
       other end.  When you enter the number, it is dialed.  If there is an
       answer, you can talk.  If not, the walkie-talkie is deactivated when
       you hang up.  If not active, broadcast. */\fC
    dialOrTalk(holding(self))
}
.Re
throw()
.In
.nf
init(phoneNumber, state)
{
    self.phoneNumber = phoneNumber
    self.state = state
}
.Dy
smash()
.As
ANSWERED*
ANSWER*
HANG*
HUNGUP*
UNHOOK*
RING*
DIAL*
SPEAK*
.Gr
Single static image of walkie-talkie.  Sound of phone ringing.  Sound of phone
ringing at other end of phone line.  Busy signal sound.  Dial tone.  Dialing
sounds (touch tones or rotary clanks).  Clicking and clunking when the
receiver is picked up or hung up or when the person at the other end hangs up.
.Hb
ANSWER
DIAL
GET
HANG
PUT
TALK
THROW
UNHOOK
.En
.Ob
wall
.De
An interior or exterior wall section.
.Fu
Graphic element in buildings.  Obstruction.
.No
A wall is just an opaque rectangle that sits edgewise on the ground.  The edge
that sits on the ground defines an impenetrable linear barrier.  The only way
past a wall is to go through a door (or go around it if it is small, of
course).  Wall objects are usually (but not exclusively) components of
building objects.  When they are building components they are not known to the
host, functioning as roof objects do.  When they stand alone, they \fIare\fP
known to the host.  Walls are painted on the background or foreground as
trapezoids.
.Sy
\fRNone.
.Pr
length          /* How long the wall is.  Its baseline runs 'length' units
                   from the location point in the direction specified by the
                   'orientation' property. */
height          /* How high the wall is. */
orientation     /* What direction the wall runs from the location point, in
                   the form of a number from 0 to 8, where 0 indicates WEST, 1
                   indicates NORTHWEST, 2 indicates NORTH, and so on clockwise
                   around the compass rose.  WEST is always taken as the
                   direction directly away from the viewpoint, even if this
                   is not true West. */
wallPattern     /* The color and texture that the wall appears. */
.Cl
\fRNo class properties.
.Hp
\fRNo other properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(length, height, orientation, wallPattern)
{
    self.length = length
    self.height = height
    self.orientation = orientation
    self.wallPattern = wallPattern
}
.Dy
nullDestroy()
.As
\fRNone.
.Gr
Wall image, rendered as one or more texture-mapped trapezoids by the
background generator.
.Hb
\fRNone.
.En
.Ob
water
.De
You know what water is.
.Fu
A useful fluid.
.No
This is not really an object.  It never exists.  This entry is just here so
that we can say a few words about it.  Water is always manipulated indirectly
using a container.  Certain objects (pond, river, fountain, etc.) are infinite
sources of water.  From such sources it is possible to fill a water container.
The water container can then be emptied onto or into something to have an
effect.  The water itself is never actually touched or interacted with, so no
object need exist to represent it.
.Sy
\fRNone.
.Pr
\fRNo properties since it is not an object.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
\fRNo behavior of its own.  Must be manipulated indirectly using a container.
.In
\fRNone since it is not an object.
.Dy
\fRNone since it is not an object.
.As
\fRNone.
.Gr
None.
.Hb
\fRNone.
.En
.Ob
window
.De
A conventional house window.
.Fu
Graphic element in buildings.
.No
Window objects are used to decorate the outside of buildings.  Like roof
objects, they are internal to the home system.  They are rather inert.
.Sy
WINDOW_PICTURE, WINDOW_TWO_PANED, WINDOW_FOUR_PANED, WINDOW_SIX_PANED,
WINDOW_GABLED, WINDOW_SMALL, WINDOW_ROUND
.Pr
\fRNo properties.
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
depends()
.Go
goTo()
.St
cease()
.Ge
noEffect()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
/* This can't happen */
.In
.nf
init(windowStyle)
{
    self.grstyle = windowStyle
}
.Dy
smash()
.As
\fRNone.
.Gr
Single static image for each style of window.
.Hb
\fRNone.
.En
.Ob
wind-up toy
.De
Your basic windup doll or robot.
.Fu
You wind it up and it walks across the floor.
.No
The wind-up toy has a key by which you wind it.  If you wind it too far it
breaks.  If you wind it up and then set it down, it walks until it runs down.
.Sy
WINDUP_DOLL, WINDUP_ROBOT, WINDUP_PENGUIN
.Pr
windLevel       /* How wound up this device is.  Normal range is from 0 to 3.
                   Each time you wind it this level is incremented.  If you
                   increment it past 3 it breaks. */
.Cl
\fRNo class properties.
.Hp
\fRNo properties.
.Co
.Do
.nf
{
    if (holding(self)) {
        self.windLevel++
        @ self!WIND () \(-> ()
        if (self.windLevel == 1) {
            soundEffect(SOUND_WIND_1)
        } else if (self.windLevel == 2) {
            soundEffect(SOUND_WIND_2)
        } else if (self.windLevel == 3) {
            soundEffect(SOUND_WIND_3)
        } else {
            soundEffect(SOUND_SPROING)
            self.windLevel = 4
        }
    } else {
        depends()
    }
}
.Go
goTo()
.St
cease()
.Ge
goToAndGet()
.Pu
goToAndDropAt()
.Ta
broadcast()
.Re
throw()
.In
nullInit()
.Dy
smash()
.As
WIND* ()
{
    self.windLevel++
    if (self.windLevel == 1) {
        soundEffect(SOUND_WIND_1)
    } else if (self.windLevel == 2) {
        soundEffect(SOUND_WIND_2)
    } else if (self.windLevel == 3) {
        soundEffect(SOUND_WIND_3)
    } else {
        soundEffect(SOUND_SPROING)
        self.windLevel = 4
    }
}
.Gr
Single static image of wind-up toy for each style.
.Hb
GET
PUT  \fB/* *** Need special put to handle toy walking away. *** */\fC
THROW
WIND () \(-> ()
{
    if (holding(self)) {
        self.windLevel++
        if (self.windLevel > 4) {
            self.windLevel = 4
        }
        # self \(-> WIND* ()
    }
}
.En

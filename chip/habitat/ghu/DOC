/u0/chip/habitat/ghu:

	This directory contains the MASTER PL/1 source for Ghu, God's Handy
Utility.  This is the main Habitat host database management program.  The
sources here are the ones that count, not the ones on the host.  Any changes
made to Ghu on the host MUST be made in parallel to the sources here.  Better
still is to make the changes here and then copy the files to the Stratus.

We are doing one important tricky thing here.  The parse for Ghu is written
using Yacc, Unix's compiler generator program.  Yacc is a preprocessor that
takes a language grammar specification along with some fragments of code and
from this creates a table-driven parser routine to match.  However, Yacc is
designed to work with code written in C.  We are writing in PL/1 on the
Stratus, so we have some major hacks to make Yacc work correctly with PL/1.
First, Yacc has a source library from which it gets the main body of the
parser itself.  I recoded this in PL/1.  Fortunately, PL/1 and C are similar
enough that the grammar productions can be written in PL/1 and Yacc does the
right thing.  However, the parser that results is a mish-mosh of some C and
some PL/1, so we need to massage the source code AFTER Yacc has done its
thing.  For this we have some Emacs macros.  All of this is handled
automagically by 'make' using the Makefile in this directory.  The PL/1
version of the Yacc parser loop and the Emacs macros to do the conversion are
not here, but instead are in the Emacs library in my tools directory
/u0/chip/toolBox.

When you run 'make', it will take a .ply file, crank it through Yacc, and run
Emacs on it, invoking the right macros.  However, there are two stages at
which human intervention is REQUIRED.  First, Emacs macros that are invoked
automatically at Emacs startup time cannot exit Emacs, so you have to exit
manually (Emacs is invoked twice, once for the parser itself and once for the
include file that is generated for the lexer).  Second, Yacc generates some
array initialization declarations, but it doesn't know how to set the
dimensions of the arrays properly (this is because in C, the compiler can
figure out the proper length from the initialization statement, whereas PL/1
is too brain-damaged to do so).  Thus, you MUST set the array lengths manually
in the parser.  There are six arrays that must be so adjusted.  Emacs will
come up on the screen AFTER having massaged the parser code as much as it can.
The arrays of interest will have been declared with a dimension of "xxx".  YOu
can go ahead and search for this string, as these six array bounds are the
only place it appears.  You then have to count the elements in each array and
change the "xxx" to whatever the proper value is.  Note the "xxx" gets changed
to the length of the array minus one, since we are using 0-based arrays.
Confused?  Of course you are.

Also, there seems to be a limit to the length of a statement that the Stratus
PL/1 compiler can swallow, so once an array gets too big we won't be able to
add enhancements to the grammar.  We are approaching this point now.  Beware.

These are the files found here.

DOC		- This file
Makefile	- Makefile that controls the Yacc pre-processing of the
		  source, as described above.

*.pl1		- PL/1 sources for the various parts of Ghu
*.incl.pl1	- PL/1 include files for the various parts of Ghu.  In
		  addition to some general-use includes, for each file
		  'foo.pl1' file there is a corresponding 'foo.incl.pl1' file
		  that contains declaration of the procedures in 'foo.pl1' so
		  that other files can call them.

ghu.ply		- This is the Yacc input for the parser.  The final output,
		  after all the massaging described above, becomes 'ghu.pl1'
		  and 'y.tab.incl.pl1'.
y.output	- This is diagnostic output generated by Yacc.  It is not
		  important unless you are trying to diagnose ambiguities in
		  the grammar.  If so, see the Yacc documentation.
allocs.t	- For debugging alloc storage leaks, each call to alloc in Ghu
		  is tagged according to where it is used, so we can diagnose
		  later on what hasn't been freed.  This file is simply a
		  summary of what the different tag numbers mean.
keys.t		- We have defined a bunch of "\" escapes that Ghu recognizes
		  in literal character strings.  These generate the various
		  Habitat graphics characters.  This file summarizes the
		  escape codes.

This is what the various PL/1 files contain:

main.pl1			- the main program entry point (BTW, the
					version number is kept here)
add.pl1, add.incl.pl1		- code for adding new objects to database
class.pl1, class.incl.pl1	- code for class definition commands and the
					reading and writing of the class
					description file
command.pl1, command.incl.pl1	- code for flow of control and command
					execution
database.pl1, database.incl.pl1 - code for actual database I/O
display.pl1, display.incl.pl1	- code for output of data to the terminal
envcode.pl1, envcode.incl.pl1	- code for the reading and writing of macros
					to and from the environment file
environ.pl1, environ.incl.pl1	- code for environment files
expr.pl1, expr.incl.pl1		- code for expression evaluation
help.pl1, help.incl.pl1		- code to print help information
lex.pl1, lex.incl.pl1		- code for lexical analysis of input
macprint.pl1, macprint.incl.pl1 - code to print out macro code
stdio.pl1, stdio.incl.pl1 	- code for all non-database I/O
symbols.pl1, symbols.incl.pl1 	- code for symbol table management
tables.pl1, tables.incl.pl1	- code for access to various data tables
world.pl1, world.incl.pl1	- code for miscellaneous commands

ghu.incl.pl1		- universal top-level include file for Ghu

array_struct.incl.pl1	- type declaration file
command_struct.incl.pl1	- type declaration file
expr_struct.incl.pl1	- type declaration file
field_struct.incl.pl1	- type declaration file
parse_defs.incl.pl1 	- type declaration file
symbol_struct.incl.pl1 	- type declaration file
turf.incl.pl1		- type declaration file
value_struct.incl.pl1 	- type declaration file

ghu.pl1			- parser (generated by Yacc et al)
y.tab.incl.pl1		- header for lex (generated by Yacc)

